/ *! jQuery v1.10.2 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license
// @ sourceMappingURL = jquery.min.map
* /
(função (e, t) {var n, r, i = tipo de t, o = localização local, a = e.document, s = a.documentElement, l = e.jQuery, u = e. $, c = {}, p = [], f = "1.10.2", d = p.concat, h = p.push, g = p.slice, m = p.indexOf, y = c.toString, v = c. hasOwnProperty, b = f.trim, x = function (e, t) {retorna novo x.fn.init (e, t, r)}, w = / [+ -]? (?: \ d * \. | ) \ d + (?: [eE] [+ -]? \ d + |) /. fonte, T = / \ S + / g, C = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g, N = / ^ (?: \ s * (<[\ w \ W] +>) [^>] * | # ([\ w -] *)) $ /, k = / ^ <(\ w +) \ s * \ /?> (?: <\ / \ 1> |) $ /, E = / ^ [\],: {} \ s] * $ /, S = / (? : ^ |: |,) (?: \ s * \ [) + / g, A = / \\ (?: ["\\\ / bfnrt] | u [\ da-fA-F] {4}) /g,j=/"[^"\\\r\n}*"|true|false| null|-?(?::dd+\.|)\d+(?:[eE[[+--]? \ d + |) / g, D = / ^ - ms - /, L = / - ([\ da-z]) / gi, H = função (e, t) {retornar t.toUpperCase ()}, q = function (e) {(a.addEventListener || "load" === e.type || "complete" === a.readyState) && (_ (), x.ready ())}, _ = function ( ) {a.addEventListener?removeEventListener ("DOMContentLoaded", q,! 1), e.removeEventListener ("carga", q,! 1)) :( a.detachEvent ("onreadystatechange", q), e.detachEvent ("onload", q)) }; x.fn = x.prototype = {jquery: f, construtor: x, init: function (e, n, r) {var i, o; if (! e) retorna isso; if ("string" == tipo de e) {if (i = "<" === e.charAt (0) && ">" === e.charAt (e.length-1) && e.length> = 3? [null, e, null ]: N.exec (e) ,! i ||! I [1] && n) return! N || n.jquery? (N || r) .find (e): este.construtor (n) .find ( e); if (i [1]) {if (n = n instância de x? n [0]: n, x.merge (esta, x.parseHTML (i [1], n && n.nodeType? n.ownerDocument || n: a,! 0)), k.test (i [1]) && x.isPlainObject (n)) para (i in n) x.isFunction (this [i])? this [i] (n [i] ): this.attr (i, n [i]); retorne} se (o = a.getElementById (i [2]), o && o.parentNode) {if (o.id! == i [2]) return r.find (e); this.length = 1,this [0] = o} retorna this.context = a, this.selector = e, this} retorna e.nodeType? (this.context = this [0] = e, this.length = 1, this): x. isFunction (e)? r.ready (e) :( e.selector! == t && (this.selector = e.selector, this.context = e.context), x.makeArray (e, this))}, seletor : "", length: 0, toArray: function () {return g.call (this)}, get: function (e) {return null == e? this.toArray (): 0> e? this [this. comprimento + e]: este [e]}, pushStack: function (e) {var t = x.merge (this.constructor (), e); return t.prevObject = this, t.context = this.context, t }, each: function (e, t) {return x.each (this, e, t)}, ready: function (e) {return x.ready.promise (). done (e), this}, fatia: function () {return this.pushStack (g.apply (this, argumentos))}, primeiro: function () {return this.eq (0)}, last: function () {return this.eq (-1)} , eq: function (e) {var t = this.length, n = + e + (0> e? t: 0); retorna this.pushStack (n> = 0 && t> n? [this [n]]: [] )},mapa:function (e) {return this.pushStack (x.map (this, function (t, n) {retorna e.call (t, n, t)}))}}, fim: function () {retorna this.prevObject | | this.constructor (null)}, push: h, sort: []. sort, splice: []. splice}, x.fn.init.prototype = x.fn, x.extend = x.fn.extend = function () {var e, n, r, i, o, a, s = argumentos [0] || {}, l = 1, u = argumentos. comprimento, c =! 1; for ("booleano" == typeof s && (c = s, s = argumentos [1] || {}, l = 2), "objeto" == typeof s || x.isFunção (s) || (s = {}), u == = l && (s = isto, - l); u> l; l ++) if (null! = (o = argumentos [l])) para (i in o) e = s [i], r = o [i ], s! == r && (c && r && (x.isPlainObject (r) || (n = x.isArray (r)))? (n? (n =! 1, a = e && x.isArray (e)? e: []): a = e && x.isPlainObject (e)? e: {}, s [i] = x.extend (c, a, r)): r! == t && (s [i] = r)); return s}, x.extend ({expando: "jQuery" + (f + Math.random ()). replace (/ \ D / g, ""), noConflict: function (t) {return e. $ == = x && (e. $ = u), t && e.jQuery === x && (e.jQuery = l), x}, isReady:! 1, readyWait: 1, holdReady: function (e) {e? x.readyWait ++: x .ready (! 0)}, ready: function (e) {if (e ===! 0?! - x.readyWait:! x.isReady) {if (! a.body) retorna setTimeout (x.ready ); x.isReady =! 0, e! ==! 0 && - x.readyWait> 0 || (n.resolveWith (a, [x]), x.fn.trigger && x (a) .trigger ("pronto" ) .off ("pronto"))}}, isFunction: function (e) {return "function" === x.type (e)}, isArray: Array.isArray || function (e) {return "array" === x.type (e)}, isWindow: function (e) {return null! = e && e == e.window}, isNumeric: function (e) {return! isNaN (parseFloat (e)) && isFinite (e) }, digite: function (e) {return null == e? e + "": "objeto" == tipo de e || "função" == tipo de e? c [y.call (e)] || "objeto" : typeof e}, isPlainObject: function (e) {var n; if (! e || "objeto"! == x.digite (e) || e.nodeType || x.isWindow (e)) return! 1; tente {if (construtor e &&! v.call (e, "construtor") &&! v.call (e.constructor. prototype, "isPrototypeOf")) return! 1} catch (r) {return! 1} if (x.support.ownLast) for (n in e) retorne v.call (e, n); for (n em e) ; return n === t || v.call (e, n)}, isEmptyObject: function (e) {var t; para (t em e) return! 1; return! 0}, erro: function (e) {throw Error (e)}, analiseHTML: function (e, t, n) {if (! e || "string"! = typeof e) return null; "boolean" == typeof t && (n = t, t = ! 1), t = t || a; var r = k.exec (e), i =! N && []; return r? [T.createElement (r [1])] :( r = x.buildFragment ( [e], t, i), i && x (i) .remove (), x.merge ([], r.childNodes))}, parseJSON: function (n) {return e.JSON && e.JSON.parse? e. JSON.parse (n): null === n? N: "string" == tipo de n && (n = x.trim (n), n && E.test (n.replace (A, "@"). Replace (j ,"]"). replace (S, "")))? Function ("return" + n) () :( x.error ("JSON inválido:" + n), t)}, parseXML: function (n) {var r, i; if (! n || "string"! = typeof n) retorna null; tente {e.DOMParser? (i = novo DOMParser, r = i.parseFromString (n, "text / xml")) : (r = new ActiveXObject ("Microsoft.XMLDOM"), r.async = "false", r.loadXML (n))} catch (o) {r = t} retorna r && r.documentElement &&! r.getElementsByTagName ("parsererror ") .length || x.error (" XML inválido: "+ n), r}, noop: function () {}, globalEval: function (t) {t && x.trim (t) && (e.execScript || função (t) {e.eval.call (e, t)}) (t)}, camelCase: função (e) {retorne e.replace (D, "ms -"). replace (L, H)}, nodeName: function (e, t) {return e.nodeName && e.nodeName.toLowerCase () === t.toLowerCase ()}, cada um: function (e, t, n) {var r, i = 0, o = e comprimento, a = M (e);if (n) {if (a) {for (; o> i; i ++) if (r = t.apply (e [i], n), r ===! 1) break} else} para (i em e ) if (r = t.apply (e [i], n), r ===! 1) break} else if (a) {for (; o> i; i ++) if (r = t.call (e [i], i, e [i]), r ===! 1) pausa} mais para (i em e) se (r = t.call (e [i], i, e [i]), r ===! 1) break; return e}, trim: b &&! B.call ("\ ufeff \ u00a0")? Function (e) {return null == e? "": B.call (e)}: função (e) {retornar nulo == e? "" :( e + ""). substituir (C, "")}, makeArray: função (e, t) {var n = t || []; retornar nulo! = e && (M (Objeto (e))? x.merge (n, "string" == tipo de e? [e]: e): h.call (n, e)), n}, inArray: function (e , t, n) {var r; if (t) {if (m) retorna m.call (t, e, n); for (r = t.length, n = n? 0> n? Math.max ( 0, r + n): n: 0; r> n; n ++) se (n em t && t [n] === e) retornar n} retornar-1}, mesclar: função (e, n) {var r = n.length, i = e.length, o = 0; se ("número" == tipo de r) para (; r> o; o ++) e [i ++] = n [o]; caso contrário, enquanto (n [o] !== t) e [i ++] = n [o ++]; retorna e.length = i, e}, grep: function (e, t, n) {var r, i = [], o = 0, a = e .length; para (n = !! n; a> o; o ++) r = !! t (e [o], o), n! == r && i.push (e [o]); return i}, map : função (e, t, n) {var r, i = 0, o = comprimento e, a = M (e), s = []; se (a) para (; o> i; i ++) r = t (e [i], i, n), nulo! = r && (s [s.length] = r); caso contrário, para (i em e) r = t (e [i], i, n), nulo! = r && (s [s.length] = r); return d.apply ([], s)}, guid: 1, proxy: function (e, n) {var r, i, o; return "string" = = typeof n && (o = e [n], n = e, e = o), x.isFunção (e)? (r = g.call (argumentos, 2), i = function () {return e.apply ( n || isso, r.concat (g.call (argumentos)))}, i.guid = e.guid = e.guid || x.guid ++, i): t}, acesso: function (e, n, r, i, o, a, s) {var l = 0, u = comprimento.c, n = null == r; if ("objeto" === x.type (r)) {o =! 0; para (l em r) x.access (e, n, l, r [l] ,! 0, a, s)} mais se (i! == t && (o =! 0, x.isFunção (i) | | (s =! 0), c && (s? (n. chamada (e, i), n = nulo) :( c = n, n = função (e, t,n) {return c.call (x (e), n)})), n)) para (; u> l; l ++) n (e [l], r, s? i: i.call (e [ l], l, n (e [l], r))); return o? e: c? n.call (e): u? n (e [0], r): a}, now: function ( ) {return (new Date) .getTime ()}, swap: function (e, t, n, r) {var i, o, a = {}; para (o em t) a [o] = e.style [o], e.style [o] = t [o]; i = n.aplicar (e, r || []); para (o em t) e.style [o] = a [o]; return i}}), x.ready.promise = function (t) {if (! n) if (n = x.Deferred (), "complete" === a.readyState) setTimeout (x.ready); caso contrário, se (a.addEventListener) a.addEventListener ("DOMContentLoaded", q,! 1), e.addEventListener ("carga", q,! 1); else {a.attachEvent ("onreadystatechange", q), e.attachEvent ( "onload", q); var r =! 1; tente {r = null == e.frameElement && a.documentElement} catch (i) {} r && r.doScroll && function o () {if (! x.isReady) {try {r .doScroll ("left")} catch (e) {return setTimeout (o, 50)} _ (), x.ready ()}} ()} return n.promessa (t)}, x.each ("Número booleano String Função Matriz Data RegExp Objeto Erro" .split (""), função (e, t) {c ["[objeto" + t + "]"] = t. toLowerCase ()}); function M (e) {var t = e.length, n = x.type (e); return x.isWindow (e) ?! 1: 1 === e.nodeType && t?! 0: "matriz" === n || "função"! == n && (0 === t || "número" == tipo de t && t> 0 && t-1 em e)} r = x (a), função (e, t) {var n, r, i, o, a, s, l, u, c, p, f, d, h, g, m, y, v, b = "chiar" + - nova data, w = e.document, T = 0, C = 0, N = st (), k = st (), E = st (), S =! 1, A = função (e, t) {return e === t ? (S =! 0,0): 0}, j = tipo de t, D = 1 << 31, L = {}. HasOwnProperty, H = [], q = H.pop, _ = H.push, M = H.push, O = H.slice, F = H.indexOf || função (e) {var t = 0, n = this.length; for (; n> t; t ++) if (this [t] = == e) retorna t; return-1}, B = "verificado | selecionado | assíncrono | foco automático | jogo automático | controles | adiar | desabilitado | oculto | ismap | loop | múltiplo | aberto | somente leitura | necessário | escopo ", P =" [\\ x20 \\ t \\ r \\ n \ \ f] ", R =" (?: \\\\. | [\\ w-] | [^ \\ x00 - \\ xa0]) + ", W = R. substituir (" w "," w # "), $ =" \\ ["+ P +" * ("+ R +") "+ P +" * (?: ([* ^ $ |! ~]? =) "+ P +" * (? :( ['\ "]) ((?: \\\\. | [^ \\\\]) *?) \\ 3 | (" + W + ") |) |)" + P + "* \\]" , I = ":(" + R + ") (?: \\ (((['\"])) ((?: \\\\. | [^ \\\\]) *?) \\ 3 | ((?: \\\\. | [^ \\\\ () [\\]] | | + $. substituir (3,8) + ") *) |. *) \\) |)", z = RegExp ("^" + P + "+ | ((?: ^ | [^ \\\\]) (?: \\\\.) *)" + P + "+ $", "g"), X = RegExp ("^" + P + "*," + P + "*"), U = RegExp ("^" + P + "* ([> + ~] |" + P + ")" + P + "*") , V = RegExp (P + "* [+ ~]"), Y = RegExp ("= "+ P +" * ([^ \\] '\ "] *)" + P + "* \\]", "g"), J = RegExp (I), G = RegExp ("^" + W + " $ "), Q = {ID: RegExp (" ^ # ("+ R +") "), CLASSE: RegExp (" ^ \\. ("+ R +") "), TAG: RegExp (" ^ ("+ R.replace ("w", "w *") + ")"), ATTR: RegExp ("^" + $), PSEUDO: RegExp ("^" + I), FILHO: RegExp ("^ :( apenas | primeiro | último | enésimo | enésimo-último) - (filho | do tipo) (?: \\ ("+ P +" * (par | ímpar | | (([+ -] |) (\\ d *) n |) "+ P +" * (?: ([+ -] |) "+ P +" * (\\ d +) |)) "+ P +" * \\) |) "," i "), bool: RegExp ("^ (?:" + B + ") $", "i"), precisaContext: RegExp ("^" + P + "* [> + ~] |: (par | ímpar | eq | gt | lt | nth | primeiro | último) (?: \\ ("+ P +" * ((?: - \\ d)? \\ d *) "+ P +" * \\) |) (? = [^ -] | $) "," i ")}, K = / ^ [^ {] + \ {\ s * \ [nativo \ w /, Z = / ^ (?:# ([\ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, et = / ^ (?: input | selecione | textarea | botão) $ / i, tt = / ^ h \ d $ / i, nt = / '| \\ / g, rt = RegExp ("\\\\ ([\\ da-f] {1,6}" + P + "? | (" + P + ") |.)", "Ig"), it = function (e, t, n) {var r = "0x" + t-65536; retornar r! == r || n? T: 0> r ? String.fromCharCode (r + 65536): String.fromCharCode (55296 | r >> 10,56320 | 1023 & r)}; tente {M.apply (H = O.call (w.childNodes), w.childNodes), H [w.childNodes.length] .nodeType} catch (ot) {M = {apply: H.length? function (e, t) {_. apply (e, O.call (t))}: function (e, t) {var n = e.length, r = 0; while (e [n ++] = t [r ++]); e.length = n-1}}} função em (e, t, n, i) {var o, a, s, l, u, c, d, m, y, x; if ((t? tDownerDocument || t: w)! == f && p (t), t = t || f, n = n || [] ,! e || "string"! = tipo de e) return n; if (1! == (l = t.nodeType) && 9! == l) return []; if (h &&! i ) {if (o = Z.exec (e)) if (s = o [1]) {if (9 === l) {if (a = t.getElementById (s) ,! a ||! a.parentNode) return n; if (a.id === s) retorna n.push (a), n} else if (t.ownerDocument && (a = t.ownerDocument.getElementById (s)) && v (t, a) && a .id === s) retorna n.push (a), n} mais {if (o [2]) retorna M.apply (n, t.getElementsByTagName (e)), n; if ((s = o [ 3]) && r.getElementsByClassName && t.getElementsByClassName) retornam M.apply (n, t.getElementsByClassName (s)), n} if (r.qsa && (! G ||! G.test (e))) {if (m = d = b, y = t, x = 9 === l && e, 1 === l && "objeto"! == t.nodeName.toLowerCase ()) {c = mt (e), (d = t.getAttribute ( "id"))? m = d.replace (nt, "\\ $ &"): t.setAttribute ("id", m), m = "[id = '" + m + "']", u = c.length; while (u -) c [u] = m + yt (c [u]); y = V.teste (e) && t.parentNode || t, x = c.join (",") } se (x) tente {retornar M.apply (n, y.querySelectorAll (x)), n} captura (T) {} finalmente {d || t.removeAttribute ("id")}}} retornar kt (e.replace (z, "$ 1"), t, n, i)} função st () {var e = []; função t (n, r) {retornar e.push (n + = "")> o.cacheLength && delete t [e.shift ()], t [n] = r} retorno t} função lt (e) {retorno e [b] =! 0, e} função ut (e) { var t = f.createElement ("div"); tente {return !! e (t)} catch (n) {return! 1} finalmente {t.parentNode && t.parentNode.removeChild (t), t = null}} função ct (e, t) {var n = e.split ("|"), r = e.length; while (r -) o.attrHandle [n [r]] = t} função pt (e, t) {var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && (~ t.sourceIndex || D) - (~ e.sourceIndex || D); if (r) retorna r; if ( n) while (n = n.nextSibling) if (n === t) return-1; return e? 1: -1} função ft (e) {função de retorno (t) {var n = t.nodeName.toLowerCase (); return "input" === n && t.type === e}} função dt (e) {função de retorno (t) {var n = t.nodeName.toLowerCase (); return ("entrada "=== n ||" botão "=== n) && t.type === e}} função ht (e) {retornar lt (função (t) {retornar t = + t, lt (função (n , r) {var i, o = e ([], n.length, t), a = o.length; enquanto (a -) n [i = o [a]] && (n [i] =! (r [i] = n [i]))})})} s = at.isXML = função (e) {var t = e && (e.ownerDocument || e) .documentElement; return t? "HTML"! == t.nodeName:! 1}, r = at.support = {}, p = at.setDocument = função (e) {var n = e? e.ownerDocument || e: w, i = n.defaultView; return n! == f && 9 === n.nodeType && n.documentElement? (f = n, d = n.documentElement, h =! s (n), i && i.attachEvent && i! == i.top && i.attachEvent ("onbeforeunload", function () {p ()}), r.atributos = ut (função (e) {return e.className = "i",! e.getAttribute ("className")}), r.getElementsByTagName = ut (function ( e) {return e.appendChild (n.createComment (""))) ,! e.getElementsByTagName ("* "). length}), r.getElementsByClassName = ut (função (e) {return e.innerHTML =" <div class = 'a'> </div> <div class = 'a i'> </div> ", e.firstChild.className =" i ", 2 === e.getElementsByClassName (" i "). length}), r.getById = ut (função (e) {retornar d.appendChild (e) .id = b,! n.getElementsByName ||! n.getElementsByName (b). comprimento}), r.getById? (o.find.ID = function (e, t) {if (tipo de t.getElementById! == j && h) { var n = t.getElementById (e); return n && n.parentNode? [n]: []}}, o.filter.ID = function (e) {var t = e.replace (rt, it); return function ( e) {retornar e.getAttribute ("id") === t}}) :( excluir o.find.ID, o.filter.ID = function (e) {var t = e.replace (rt, it) ; função de retorno (e) {var n = tipo de e.getAttributeNode! == j && e.getAttributeNode ("id"); retorno n && n.value === t}}), o.find.TAG = r.função getElementsByTagName? (e, n) {tipo de retorno n.getElementsByTagName! == j? n.getElementsByTagName (e): t}: função (e, t) {var n, r = [], i = 0, o = t.getElementsByTagName (e); if ("*" === e) {while (n = o [i ++]) 1 === n.nodeType && r.push (n); return r} return o}, o.find .CLASS = r.getElementsByClassName && function (e, n) {tipo de retorno de n.getElementsByClassName! == j && h? N.getElementsByClassName (e): t}, m = [], g = [], (r.qsa = K.test (n.querySelectorAll)) && (ut (function (e) {e.innerHTML = "<select> <opção selecionada = ''> </option> </select>", e.querySelectorAll ("[selected]") .length || g.push ("\\ [" + P + "* (?: valor |" + B + ")"), e.querySelectorAll (": marcado"). length || g.push (": marcado ")}), ut (função (e) {var t = n.criarElement (" entrada "); t.setAttribute (" tipo ","oculto"), e.appendChild (t) .setAttribute ("t", ""), e.querySelectorAll ("[t ^ = '']"). length && g.push ("[* ^ $] =" + P + "* (?: '' | \" \ ")"), e.querySelectorAll (": enabled"). Length || g.push (": enabled", ": disabled"), e.querySelectorAll (" * ,: x "), g.push (",. *: ")})), (r.matchesSelector = K.test (y = d.webkitMatchesSelector || d.mozMatchesSelector || d.oMatchesSelector || d. msMatchesSelector)) && ut (função (e) {r.disconnectedMatch = y.call (e, "div"), y.call (e, "[s! = '']: x"), m.push ("! = ", I)}), g = g.length && RegExp (g.join (" | ")), m = m.length && RegExp (m.join (" | ")), v = K.test (d.contains) || função d.compareDocumentPosition? (e, t) {var n = 9 === e.nodeType? e.documentElement: e, r = t && t.parentNode; return e === r ||! (! r || 1! == r.nodeType ||! (n.contains? n.contains (r): e.compareDocumentPosition && 16 & e.compareDocumentPosition (r)))}: function (e, t) {if (t) while (t = t.parentNode) if (t === e) return! 0; return! 1}, A = d.compareDocumentPosition? function (e, t) {if (e === t) return S =! 0,0; var i = t.compareDocumentPosition && e.compareDocumentPosition && e.compareDocumentPosition (t); retorna i? 1 & i ||! r.sortDetached && t.compareDocumentPosition (e) === i? e === n || v (w, e)? - 1: t === n || v (w, t)? 1: c? F.call (c, e) -F.call (c, t ): 0: 4 & i? -1: 1: e.compareDocumentPosition? -1: 1}: function (e, t) {var r, i = 0, o = e.parentNode, a = t.parentNode, s = [ e], l = [t]; se (e === t) retorna S =! 0,0; if (! o ||! a) retorna e === n? -1: t === n? 1: o? -1: a? 1: c? F.call (c, e) -F.call (c, t): 0; if (o === a) return pt (e, t); r = e; while (r = r.parentNode) s.unshift (r); r = t; while (r = r.parentNode) l.unshift (r); while (s [i] === l [i] ) i ++;retornar i? pt (s [i], l [i]): s [i] === w? -1: l [i] === w? 1: 0}, n): f}, em. corresponde = função (e, t) {retorna at (e, nulo, nulo, t)}, at.matchesSelector = função (e, t) {if ((e.ownerDocument || e)! == f && p (e) , t = t.replace (Y, "= '$ 1']"),! (! r.matchesSelector ||! h || m && m.test (t) || g && g.test (t))) tente {var n = y.call (e, t); if (n || r.disconnectedMatch || e.document && 11! == e.document.nodeType) return n} catch (i) {} return at (t, f, null, [e]). length> 0}, at.contains = function (e, t) {return (e.ownerDocument || e)! == f && p (e), v (e, t)}, at.attr = função (e, n) {(e.ownerDocument || e)! == f && p (e); var i = o.attrHandle [n.toLowerCase ()], a = i && L.call (o.attrHandle, n.toLowerCase ())? i (e, n,! h): t; retorna a === t? r.atributos ||! h? e.getAttribute (n) :( a = e.getAttributeNode (n)) && a. especificado? a.value: null: a}, at.error = function (e) {throw Error ("Erro de sintaxe,expressão não reconhecida: "+ e)}, at.uniqueSort = função (e) {var t, n = [], i = 0, o = 0; if (S =! r.detectDuplicates, c =! r.sortStable && e. fatia (0), e.sort (A), S) {while (t = e [o ++]) t === e [o] && (i = n.push (o)); while (i--) e.splice (n [i], 1)} retorna e}, a = at.getText = função (e) {var t, n = "", r = 0, i = e.nodeType; if (i) { if (1 === i || 9 === i || 11 === i) {if ("string" == tipo de e.textContent) retorna e.textContent; for (e = e.firstChild; e; e = e.nextSibling) n + = a (e)} else if (3 === i || 4 === i) retorna e.nodeValue} else para (; t = e [r]; r ++) n + = a (t); return n}, o = at.selectors = {cacheLength: 50, createPseudo: lt, match: Q, attrHandle: {}, encontre: {}, relativo: {">": {dir: "parentNode" , primeiro:! 0}, "": {dir: "parentNode"}, "+": {dir: "previousSibling", primeiro:! 0}, "~": {dir: "previousSibling"}}, preFilter: {ATTR: função (e) {retorne e [1] = e [1].substituir (rt, it), e [3] = (e [4] || e [5] || ""). substituir (rt, it), "~ =" === e [2] && (e [3] = "" + e [3] + ""), e.slice (0,4)}, CRIANÇA: function (e) {return e [1] = e [1] .toLowerCase (), "enésimo "=== e [1]. fatia (0,3)? (e [3] || no erro (e [0]), e [4] = + (e [4]? e [5] + (e [6] || 1): 2 * ("par" === e [3] || "ímpar" === e [3])), e [5] = + (e [7] + e [8] || "ímpar" === e [3])): e [3] && at.error (e [0]), e}, PSEUDO: função (e) {var n, r =! e [5] && e [2]; return Q.CHILD.test (e [0])? Null: (e [3] && e [4]! == t? E [2] = e [4]: ​​r && J.test (r) && (n = mt (r,! 0)) && (n = r.indexOf (")", r.length-n) -r.length) && (e [0] = e [0]). fatia (0, n), e [2] = r.slice (0, n)), e.slice (0,3))}}, filtro: {TAG: function (e) {var t = e.replace (rt, it) .toLowerCase (); return "*" === e? function () {return! 0}: function (e) {return e.nodeName && e.nodeName.toLowerCase () === t}}, CLASS: function (e) {var t = N [e + ""]; retorna t || (t = RegExp ("(^ |" + P + ")" + e + "( "+ P +" | $) ")) && N (e, função (e) {return t.test (" string "== tipo de e.className && e.className || tipo de e.getAttribute! == j && e.getAttribute (" class ") ||" ")})}, ATTR: function (e, t, n) {função de retorno (r) {var i = at.attr (r, e); return null == i?"! = " === t: t? (i + = "", "=" === t? i === n: "! =" === t? i! == n: "^ =" === t ? n && 0 === i.indexOf (n): "* =" === t? n && i.indexOf (n)> - 1: "$ =" === t? n && i.slice (-n.length) = == n: "~ =" === t? ("" + i + ""). índiceDe (n)> - 1: "| =" === t? i === n || i.slice ( 0, n.length + 1) === n + "-" :! 1) :! 0}}, CHILD: function (e, t, n, r, i) {var o = "enésimo"! == e . fatia (0,3),a = "last"! == e.slice (-4), s = "do tipo" === t; return 1 === r && 0 === i? function (e) {return !! e.parentNode }: function (t, n, l) {var u, c, p, f, d, h, g = o! == a? "nextSibling": "previousSibling", m = t.parentNode, y = s && t. nodeName.toLowerCase (), v =! l && s; if (m) {if (o) {while (g) {p = t; while (p = p [g]) if (s? p.nodeName.toLowerCase () === y: 1 === p.nodeType) return! 1; h = g = "only" === e &&! h && "nextSibling"} return! 0} if (h = [a? m.firstChild : m.lastChild], a && v) {c = m [b] || (m [b] = {}), u = c [e] || [], d = u [0] === T&& [1 ], f = u [0] === T&& [2], p = d && m.childNodes [d]; while (p = ++ d && p && p [g] || (f = d = 0) || h.pop ( )) if (1 === p.nodeType && ++ f && p === t) {c [e] = [T, d, f]; break}} else if (v && (u = (t [b] || (t [b] = {})) [e]) && u [0] === T) f = u [1]; caso contrário, enquanto (p = ++ d && p && p [g] || (f = d = 0) || h.pop ()) if ((s? p.nodeName.toLowerCase () === y: 1 === p.nodeType) && ++ f && (v && ((p [b] || (p [b] = { })) [e] = [T, f]), p === t)) break; return f- = i, f === r || 0 === f% r && f / r> = 0}} } PSEUDO: function (e, t) {var n, r = o.pseudos [e] || o.setFilters [e.toLowerCase ()] || at.error ("pseudo não suportado:" + e); return r [b]? r (t): comprimento.rr> 1? (n = [e, e, "", t], o.setFilters.hasOwnProperty (e.toLowerCase ())? lt (function (e, n ) {var i, o = r (e, t), a = o.length; while (a -) i = F.call (e, o [a]), e [i] =! (n [i ] = o [a])}): função (e) {retorna r (e, 0, n)}): r}}, pseudos: {not: lt (função (e) {var t = [], n = [], r = l (e.replace (z, "$ 1")); return r [b]? lt (função (e, t, n, i) {var o, a = r (e, null, i, []), s = e.length; while (s -) (o = a [s]) && (e [s] =! (t [s] = o))}): function (e, i, o) {return t [0] = e, r (t, nulo, o, n) ,! n.pop ()}}), possui: lt (function (e) {return function (t) {return em (e, t) .length> 0}}), contém:lt (function (e) {return function (t) {return (t.textContent || t.innerText || a (t)). indexOf (e)> - 1}}), lang: lt (function (e) {return G.test (e || "") || at.error ("idioma não suportado:" + e), e = e.replace (rt, it) .toLowerCase (), function (t) {var n; faça if (n = h? t.lang: t.getAttribute ("xml: lang") || t.getAttribute ("lang")) retorne n = n.toLowerCase (), n === e || 0 = == n.indexOf (e + "-"); while ((t = t.parentNode) && 1 === t.nodeType); return! 1}}), target: function (t) {var n = e.location && e .location.hash; return n && n.slice (1) === t.id}, raiz: função (e) {retorno e === d}, foco: função (e) {retorno e === f.activeElement && (! f.hasFocus || f.hasFocus ()) && !! (e.type || e.href || ~ e.tabIndex)}, ativado: function (e) {return e.disabled === 1 }, desabilitado: function (e) {return e.disabled ===! 0}, verificado: function (e) {var t = e.nodeName.toLowerCase (); return "input "=== t && !! e.checked ||" opção "=== t && !! e.selected}, selecionado: função (e) {retornar e.parentNode && e.parentNode.selectedIndex, e.selected ===! 0}, vazio: function (e) {for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeName> "@" || 3 === e.nodeType || 4 === e.nodeType) return! 1; return! 0}, pai: função (e) {retorno! o.pseudos.empty (e)}, cabeçalho: função (e) {retorno tt.test (e.nodeName)}, input: function (e) {return et.test (e.nodeName)}, button: function (e) {var t = e.nodeName.toLowerCase (); return "input" === t && "button" === e.type || "botão" === t}, texto: função (e) {var t; retornar "entrada" === e.nodeName.toLowerCase () && "text" === e.type && (null == (t = e.getAttribute ("tipo")) || t.toLowerCase () === e.type)}, primeiro: ht (function () {return [0]}), último: ht (function (e, t) {return [t-1]}), eq:ht (função (e, t, n) {retornar [0> n? n + t: n]}), par: ht (função (e, t) {var n = 0; para (; t> n; n + = 2) e.push (n); return e}), ímpar: ht (função (e, t) {var n = 1; para (; t> n; n + = 2) e.push (n); return e}), lt: ht (função (e, t, n) {var r = 0> n? n + t: n; para (; - r> = 0;) e.push (r); return e }), gt: ht (função (e, t, n) {var r = 0> n? n + t: n; para (; t> ++ r;) e.push (r); return e}) }}, o.pseudos.nth = o.pseudos.eq; for (n em {radio:! 0, caixa de seleção:! 0, arquivo:! 0, senha:! 0, imagem:! 0}) o.pseudos [ n] = ft (n); para (n em {submit:! 0, reset:! 0}) o.pseudos [n] = dt (n); função gt () {} gt.prototype = o.filters = o.pseudos, o.setFilters = new gt; função mt (e, t) {var n, r, i, a, s, l, u, c = k [e + ""]; se (c) retornar t? 0: c.slice (0); s = e, l = [], u = o.preFilter; while (s) {(! N || (r = X.exec (s))) && (r && (s = s.slice (r [0] .length) || s), l.push (i = [])), n =! 1, (r = U.exec (s)) && (n = r.shift (), i.push ({valor: n, digite: r [0]. substituir (z, "")}), s = s.slice (ncomprimento)); para (a no filtro)! (r = Q [a] .exec (s)) || u [a] &&! (r = u [a] (r)) || (n = r.shift (), i.push ({valor: n, tipo: a, corresponde a: r}), s = s.slice (n.length)); if (! n) break} retorna t? s.length : s? at.error (e): k (e, l) .slice (0)} função yt (e) {var t = 0, n = comprimento e, r = ""; para (; n> t ; t ++) r + = e [t] .valor; return r} função vt (e, t, n) {var r = t.dir, o = n && "parentNode" === r, a = C ++; return t. primeiro? function (t, n, i) {while (t = t [r]) if (1 === t.nodeType || o) retorna e (t, n, i)}: function (t, n, s) {var l, u, c, p = T + "" + a; if (s) {while (t = t [r]) if ((1 === t.nodeType || o) && e (t, n, s)) return! 0} else while (t = t [r]) if (1 === t.nodeType || o) if (c = t [b] || (t [b] = {}) ), (u = c [r]) && u [0] === p) {if ((l = u [1]) ===! 0 || l === i) retornar l ===! 0 } caso contrário, se (u = c [r] = [p], u [1] = e (t, n, s) || i, u [1] ===! 0) retorne! 0}} função bt ( e) {return e.length> 1? função (t, n, r) {vari = e.length; while (i -) if (! e [i] (t, n, r)) retorna! 1 ; return! 0}:e [0]} função xt (e, t, n, r, i) {var o, a = [], s = 0, l = comprimento e, u = nulo! = t; para (; l> s ; s ++) (o = e [s]) && (! n || n (o, r, i)) && (a.push (o), u &&t.push (s)); retorna uma função} wt (e , t, n, r, i, o) {return r &&! r [b] && (r = wt (r)), i &&! i [b] && (i = wt (i, o)), lt (função (o, a, s, l) {var u, c, p, f = [], d = [], h = a.length, g = o || Nt (t || "*", s.nodeType ? [s]: s, []), m =! e ||! o && t? g: xt (g, f, e, s, l), y = n? i || (o? e: h || r)? []: a: m; se (n && n (m, y, s, l), r) {u = xt (y, d), r (u, [], s, l), c = u .length; while (c -) (p = u [c]) && (y [d [c]] =! (m [d [c]] = p))} if (o) {if (i | | e) {if (i) {u = [], c = y.length; while (c -) (p = y [c]) && u.push (m [c] = p); i (nulo, y = [], u, l)} c = y.length; while (c -) (p = y [c]) && (u = i? F.call (o, p): f [c]) > -1 && (o [u] =! (A [u] = p))}} else y = xt (y === a? Y.splice (h, y.length): y), i? I ( null, a, y, l): M.apply (a, y)})} function Tt (e) {var t, n, r, i = comprimento e, a = o.relativo [e [0].tipo], s = a || o.relativo [""], l = a? 1: 0, c = vt (função (e) {retorno e === t}, s,! 0), p = vt (função (e) {retornar F.call (t, e)> - 1}, s,! 0), f = [função (e, n, r) {retornar! a && (r || n! == u ) || ((t = n) .nodeType? c (e, n, r): p (e, n, r))}]; for (; i> l; l ++) if (n = o.relative [ e [l] .type]) f = [vt (bt (f), n)]; caso contrário, {if (n = o.filter [e [l] .type] .apply (null, e [l] .matches ), n [b]) {for (r = ++ l; i> r; r ++) if (o.relative [e [r] .type]) break; return wt (l> 1 && bt (f), l> 1 && yt (e.slice (0, l-1) .concat ({value: "" === e [l-2] .type? "*": ""})). Replace (z, "$ 1") , n, r> l && Tt (e.slice (l, r)), i> r && Tt (e = e.slice (r)), i> r && yt (e))} f.push (n)} return bt (f )} função Ct (e, t) {var n = 0, r = comprimento t> 0, a = comprimento e comprimento> 0, s = função (s, l, c, p, d) {var h, g , m, y = [], v = 0, b = "0", x = s && [], w = nulo! = d, C = u, N = s || a && o.find.TAG ("*", d &Como você pode ver no exemplo a seguir, você pode usar o seguinte método: ();) (); () (); () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () h = N [b]); b ++) {if (a && h) {g = 0; while (m = e [g ++]) if (m (h, l, c)) {p.push (h); break} w && (T = k, i = ++ n)} r && ((h =! m && h) && v -, s && x.push (h))} if (v + = b, r &&b! == v) {g = 0; while (m = t [g ++]) m (x, y, l, c); if (s) {if (v> 0) enquanto (b -) x [b] || y [b] || ( y [b] = q.call (p)); y = xt (y)} M.apply (p, y), w &&! s && y.length> 0 && v + t.length> 1 && at.uniqueSort (p)} retornar w && (T = k, u = C), x}; retorna r? Lt (s): s} l = at.compile = função (e, t) {var n, r = [], i = [], o = E [e + ""]; se (! O) {t || (t = mt (e)), n = comprimento de t; enquanto (n -) o = Tt (t [n]), o [ b]? r.push (o): i.push (o); o = E (e, Ct (i, r))} return o}; função Nt (e, t, n) {var r = 0, i = t.length; para (; i> r; r ++) em (e, t [r], n); return n} função kt (e, t, n, i) {var a, s, u, c , p, f = mt (e); if (! i && 1 === f.comprimento) {if (s = f [0] = f [0]. fatia (0), s.length> 2 && "ID" === (u = s [0]). digite && r.getById && 9 === t. nodeType && h && o.relative [s [1] .type]) {if (t = (o.find.ID (u.matches [0]. substitua (rt, it), t) || []) [0] ,! t) return n; e = e.slice (s.shift (). value.length)} a = Q.needsContext.test (e)? 0: s.length; while (a -) {if (u = s [a], o.relativo [c = u.type]) break; if ((p = o.find [c]) && (i = p (u.matches [0] .replace (rt, it), V.test (s [0] .type) && t.parentNode || t))) {if (s.splice (a, 1), e = comprimento e & yt (s) ,! e) retornam M.apply (n , i), n; break}}} retorna l (e, f) (i, t,! h, n, V.test (e)), n} r.sortStable = b.split (""). (A) .join ("") === b, r.detectDuplicates = S, p (), r.sortDetached = ut (função (e) {return 1 & e.compareDocumentPosition (f.createElement ("div"))} ), ut (função (e) {return e.innerHTML = "<a href='#'> </a>", "# "=== e.firstChild.getAttribute (" href ")}) || ct (" tipo | href | height | width ", função (e, n, r) {return r? t: e.getAttribute (n , "type" === n.toLowerCase ()? 1: 2)}), r.atributes && ut (função (e) {retorne e.innerHTML = "<input />", e.firstChild.setAttribute ("value" , ""), "" === e.firstChild.getAttribute ("valor")}) || ct ("valor", função (e, n, r) {retornar r || "entrada"! == e .nodeName.toLowerCase ()? t: e.defaultValue}), ut (função (e) {return null == e.getAttribute ("disabled")}) || ct (B, função (e, n, r) {var i; return r? t: (i = e.getAttributeNode (n)) && i.especified? i.value: e [n] ===! 0? n.toLowerCase (): null}), x.find = at, x.expr = at.selectors, x.expr [":"] = x.expr.pseudos, x.unique = at.uniqueSort, x.text = at.getText, x.isXMLDoc = at.isXML, x.contains = at.contains} (e); var O = {};função F (e) {var t = O [e] = {}; retorna x.each (e.match (T) || [], função (e, n) {t [n] =! 0}), t} x.Callbacks = function (e) {e = "string" == tipo de e? O [e] || F (e): x.extend ({}, e); var n, r, i, o , a, s, l = [], u =! e.once && [], c = função (t) {para (r = e.memória && t, i =! 0, a = s || 0, s = 0, o = l.length, n =! 0; l & o> a; a ++) if (l [a] .aplicar (t [0], t [1]) ===! 1 && e.stopOnFalse) {r =! 1; break} n =! 1, l && (u? u.length && c (u.shift ()): r? l = []: p.disable ())}, p = {add: function () {if (l) {var t = l.length; (função i (t) {x.each (t, função (t, n) {var r = x.type (n); "function" === r? e.unique && p. tem (n) || l.push (n): n && n.length && "string"! == r && i (n)})}) (argumentos), n? o = l.length: r && (s = t, c ( r))} retorna isso}, remove: function () {retorna l && x.each (argumentos, função (e, t) {var r; while ((r = x.inArray (t, l, r)))> - 1 ) l.splice (r, 1), n ​​&& (o>= r && o -, a> = r && a -)}), this}, possui: function (e) {return e? x.inArray (e, l)> - 1:! (! l ||! l.length )}, vazio: function () {retorne l = [], o = 0, isto}, desative: function () {retorne l = u = r = t, isto}, desabilitei: function () {retorne! l} , lock: function () {return u = t, r || p.disable (), this}, locked: function () {return! u}, fireWith: function (e, t) {return! l || i && ! u || (t = t || [], t = [e, t.slice? t.slice (): t], n? u.push (t): c (t)), isto}, fogo : function () {return p.fireCom (this, argumentos), this}, acionado: function () {return !! i}}; return p}, x.extend ({adiado: function (e) {var t = [["resolver", "pronto", x.Callbacks ("uma vez memória"), "resolvido"], ["rejeitar", "falhar", x.Callbacks ("uma vez memória"), "rejeitado"], [ "notificar", "progresso", x.Callbacks ("memory")]], n = "pendente", r = {state: function () {return n},sempre: function () {retorna i.done (argumentos) .falha (argumentos), isso}, então: function () {var e = argumentos; retorna x.Deferred (função (n) {x.each (t, function (t, o) {var a = o [0], s = x.isFunção (e [t]) && e [t]; i [o [1]] (função () {var e = s && s.apply (this , argumentos); e && x.isFunction (e.promise)? e.promise (). done (n.resolve) .fail (n.reject) .progress (n.notify): n [a + "With"] (this = == r? n.promise (): isto, s? [e]: argumentos)})}), e = null}). promessa ()}, promessa: função (e) {retorno nulo! = e? x .extend (e, r): r}}, i = {}; retorna r.pipe = r.then, x.each (t, função (e, o) {var a = o [2], s = o [3]; r [o [1]] = a.add, s && a.add (function () {n = s}, t [1 ^ e] [2] .disable, t [2] [2] .lock ), i [o [0]] = função () {retorna i [o [0] + "With"] (isto === i? r: isto, argumentos), isto}, i [o [0] + "With"] = a.fireWith}), r.promise (i), e && e.call (i, i), i}, quando: function (e) {var t = 0, n = g.call (argumentos) , r = n.length,i = 1! == r || e && x.isFunction (e.promise)? r: 0, o = 1 === i? e: x.Deferido (), a = função (e, t, n) {return função (r) {t [e] = isso, n [e] = argumentos.length> 1? g.call (argumentos): r, n === s? o.notifyWith (t, n): - i || o.resolveWith (t, n)}}, s, l, u; if (r> 1) para (s = matriz (r), l = matriz (r), u = matriz (r); r> t; t ++) n [t] && x.isFunction (n [t] .promise)? n [t] .promise (). done (a (t, u, n)). fail (o.reject) .progress ( a (t, l, s)): - i; return i || o.resolveWith (u, n), o.promise ()}}), x.support = function (t) {var n, r, o, s, l, u, c, p, f, d = a.createElement ("div"); if (d.setAttribute ("className", "t"), d.innerHTML = "<link /> < tabela> </table> <a href='/a'> a </a> <input type = 'checkbox' /> ", n = d.getElementsByTagName (" * ") || [], r = d. getElementsByTagName ("a") [0] ,! r ||! r.style ||! n.length) return t; s = a.createElement ("selecione "), u = s.appendChild (a.createElement (" opção ")), o = d.getElementsByTagName (" input ") [0], r.style.cssText =" top: 1px; float: esquerda; opacidade : .5 ", t.getSetAttribute =" t "! == d.className, t.leadingWhitespace = 3 === d.firstChild.nodeType, t.tbody =! D.getElementsByTagName (" tbody "). Length, t .htmlSerialize = !! d.getElementsByTagName ("link"). length, t.style = / top / .test (r.getAttribute ("style")), t.hrefNormalized = "/ a" === r.getAttribute ("href"), t.opacidade = / ^ 0.5 / .test (r.style.opacidade), t.cssFloat = !! r.style.cssFloat, t.checkOn = !! o.value, t.optSelected = u.selected, t.enctype = !! a.createElement ("form"). enctype, t.html5Clone = "<: nav> </: nav>"! == a.createElement ("nav"). cloneNode ( ! 0) .outerHTML, t.inlineBlockNeedsLayout =! 1, t.shrinkWrapBlocks =! 1, t.pixelPosition =! 1, t.deleteExpando =! 0, t.noCloneEvent =! 0, t.reliableMarginRight =! 0, t.boxSizingReliable =! 0, o.checked =! 0, t.noCloneChecked = o.cloneNode (! 0) .checked, s.disabled =! 0, t.optDisabled =! U.disabled; tente {excluir d.test} captura (h) {t.deleteExpando =! 1} o = a.createElement ("entrada"), o.setAttribute ("value" , ""), t.input = "" === o.getAttribute ("valor"), o.value = "t", o.setAttribute ("tipo", "rádio"), t.radioValue = "t "=== o.valor, o.setAttribute (" marcado "," t "), o.setAttribute (" nome "," t "), l = a.createDocumentFragment (), l.appendChild (o), t .appendChecked = o.checked, t.checkClone = l.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, d.attachEvent && (d.attachEvent ("onclick", função () {t.noCloneEvent =! 1}), d.cloneNode (! 0) .click ()); para (f em {submit:! 0, change:! 0, focusin :!0}) d.setAttribute (c = "on" + f, "t"), t [f + "Bubbles"] = c em e || d.atributos [c] .expando ===! 1; d.style .backgroundClip = "caixa de conteúdo", d.cloneNode (! 0) .style.backgroundClip = "", t.clearCloneStyle = "caixa de conteúdo" === d.style.backgroundClip; for (f em x (t) ) break; return t.ownLast = "0"! == f, x (function () {var n, r, o, s = "preenchimento: 0; margem: 0; borda: 0; display: block; box- dimensionamento: caixa de conteúdo; -moz-caixa-dimensionamento: caixa de conteúdo; -webkit-caixa-dimensionamento: caixa de conteúdo; ", l = a.getElementsByTagName (" body ") [0]; l && (n = a. createElement ("div"), n.style.cssText = "borda: 0; largura: 0; altura: 0; posição: absoluta; parte superior: 0; esquerda: -9999px; margem superior: 1px", l.appendChild ( n) .appendChild (d), d.innerHTML = "<tabela> <tr> <td> </td> <td> t </td> </tr> </table>", o = d.getElementsByTagName ("td"), o [0] .style.cssText = "preenchimento: 0; margem: 0; margem: 0; borda: 0; exibição: nenhuma", p = 0 === o [0] .offsetHeight, o [0 ] .style.display = "", o [1] .style.display = "nenhum", t.reliableHiddenOffsets = p && 0 === o [0] .offsetHeight, d.innerHTML = "", d.style.cssText = "dimensionamento de caixa: borda-caixa; -moz-caixa-dimensionamento: borda-caixa; -webkit-tamanho-caixa: borda-caixa; preenchimento: 1px; borda: 1px; exibição: bloco; largura: 4px; margem-superior : 1%; position: absolute; top: 1%; ", x.swap (l, null! = L.style.zoom? {Zoom: 1}: {}, function () {t.boxSizing = 4 == = d.offsetWidth}), e.getComputedStyle && (t.pixelPosition = "1%"! == (e.getComputedStyle (d, nulo) || {}). top, t.boxSizingReliable = "4px" === ( e.getComputedStyle (n, nulo) || {width: "4px"}). width, r = d.appendChild (a.createElement ("div")), r.style.cssText = d.style.cssText = s , estilo.marginRight = r.style. largura = "0", d.style. largura = "1px", t.reliableMarginRight =! parseFloat ((e.getComputedStyle (r, nulo) || {}). marginRight)), tipo de d .style.zoom! == i && (d.innerHTML = "", d.style.cssText = s + "width: 1px; padding: 1px; display: inline; zoom: 1", t.inlineBlockNeedsLayout = 3 === .offsetWidth, d.style.display = "bloco", d.innerHTML = "<div> </div>", d.firstChild.style.width = "5px", t.shrinkWrapBlocks = 3! == d.offsetWidth , t.inlineBlockNeedsLayout && (l.style.zoom = 1)), l.removeChild (n), n = d = o = r = nulo)}), n = s = l = u = r = o = nulo, t1 ", t.inlineBlockNeedsLayout = 3 === d.offsetWidth, d.style.display =" bloco ", d.innerHTML =" <div> </div> ", d.firstChild.style.width =" 5px " , t.shrinkWrapBlocks = 3! == d.offsetWidth, t.inlineBlockNeedsLayout && (l.style.zoom = 1)), l.removeChild (n), n = d = o = r = nulo)}), n = s = l = u = r = o = nulo, t1 ", t.inlineBlockNeedsLayout = 3 === d.offsetWidth, d.style.display =" bloco ", d.innerHTML =" <div> </div> ", d.firstChild.style.width =" 5px " , t.shrinkWrapBlocks = 3! == d.offsetWidth, t.inlineBlockNeedsLayout && (l.style.zoom = 1)), l.removeChild (n), n = d = o = r = nulo)}), n = s = l = u = r = o = nulo, t
} ({}); var B = / (?: \ {[\ s \ S] * \} | \ [[\ s \ S] * \]) $ /, P = / ([AZ]) / g ; function R (e, n, r, i) {if (x.acceptData (e)) {var o, a, s = x.expando, l = e.nodeType, u = l? x.cache: e, c = l? e [s]: e [s] && s; if (c && u [c] && (i || u [c] .dados) || r! == t || "string"! = tipo de n) retornar c || (c = l? e [s] = p.pop () || x.guid ++: s), u [c] || (u [c] = l? {}: {toJSON: x. noop}), ("objeto" == tipo de n || "função" = tipo de n) && (i? u [c] = x.extend (u [c], n): u [c] .data = x.extend (u [c] .dados, n)), a = u [c], i || (a.data || (a.data = {}), a = a.data), r! = = t && (a [x.camelCase (n)] = r), "string" == tipo de n? (o = a [n], nulo == o && (o = a [x.camelCase (n)])) : o = a, o}} função W (e, t, n) {if (x.acceptData (e)) {var r, i, o = e.nodeType, a = o? x.cache: e, s = o? e [x.expando]: x.expando; if (a [s]) {if (t && (r = n? a [s]: a [s] .dados)) {x.isArray (t) ? t = t.concat (x.map (t, x.camelCase)): t em r? t = [t] :( t = x.camelCase (t), t = t em r? [t]: t .split ("")), i = t.length; while (i -) exclui r [t [i]]; if (n?! I (r) :! x.isEmptyObject (r)) return} (n || (excluir dados [s]. I (a [s]))) && (o? x.cleanData ([e] ,! 0): x.support.deleteExpando || a! = a.window? excluir a [s]: a [s] = nulo)}}} x.extend ({cache: {}, noData: {applet:! 0, incorporação:! 0, objeto: "clsid: D27CDB6E-AE6D-11cf- 96B8-444553540000 "}, hasData: function (e) {return e = e.nodeType? X.cache [e [x.expando]]: e [x.expando], !! e &&! I (e)}, dados : função (e, t, n) {retorna R (e, t, n)}, removeData: função (e, t) {retorna W (e, t)}, _ data: função (e, t, n) { return R (e, t, n,! 0)}, _ removeData: function (e, t) {return W (e, t,! 0)}, acceptData: function (e) {if (e.nodeType && 1! == e.nodeType && 9! == e.nodeType) return! 1; var t = e.nodeName && x.noData [e.nodeName.toLowerCase ()]; return! t || t! ==! 0 && e.getAttribute ("classid") === t}}), x.fn.extend ({dados: função (e, n) {var r, i,o = nulo, a = 0, s = este [0]; if (e === t) {if (this.length && (o = x.data (s), 1 === s.nodeType &&! x._data (s, "parsedAttrs"))) {for (r = s.attributes; r.length> a; a ++) i = r [a] .name, 0 === i.indexOf ("data -") && ( i = x.camelCase (i.slice (5)), $ (s, i, o [i])); x._dados (s, "parsedAttrs",! 0)} retornar o} retornar "objeto" == tipo de e? this.each (function () {x.data (this, e)}): argumentos.length> 1? this.each (function () {x.data (this, e, n)}): s $ (s, e, x.data (s, e)): null}, removeData: function (e) {retorna this.each (function () {x.removeData (this, e)})}}); função $ (e, n, r) {if (r === t && 1 === e.nodeType) {var i = "data -" + n.replace (P, "- $ 1"). toLowerCase (); if (r = e.getAttribute (i), "string" == tipo de r) {try {r = "true" === r?! 0: "false" === r?! 1: "null" == = r? null: + r + "" === r? + r: B.teste (r)? x.parseJSON (r):r} catch (o) {} x.data (e, n, r)} else r = t} retorna r} função I (e) {var t; para (t em e) if (("data"! = = t ||! x.isEmptyObject (e [t])) && "toJSON"! == t) return! 1; return! 0} x.extend ({fila: function (e, n, r) {var i ; return e? (n = (n || "fx") + "fila", i = x._dados (e, n), r && (! i || x.isArray (r)? i = x._dados ( e, n, x.makeArray (r)): i.push (r)), i || []): t}, desenfileire: função (e, t) {t = t || "fx"; var n = x.queue (e, t), r = n.length, i = n.shift (), o = x._queueHooks (e, t), a = function () {x.dequeue (e, t)} ; "inprogress" === i && (i = n.shift (), r -), i && ("fx" === t && n.unshift ("inprogress"), exclua o.stop, i.call (e, a, o)) ,! r && o && o.empty.fire ()}, _ queueHooks: function (e, t) {var n = t + "queueHooks"; retorna x._dados (e, n) || x._dados (e, n, {vazio: x.Callbacks ("uma vez memória"). add (function () {x._removeData (e,t + "fila"), x._removeData (e, n)})})}}), x.fn.extend ({fila: função (e, n) {var r = 2; retornar "string"! = typeof e && (n = e, e = "fx", r -), r> argument.length? x.queue (this [0], e): n === t? this: this.each (function () {var t = x.queue (this, e, n); x._queueHooks (this, e), "fx" === e && "inprogress"! == t [0] && x.dequeue (this, e)} )}, dequeue: function (e) {retorna this.each (function () {x.dequeue (this, e)})}, delay: function (e, t) {return e = x.fx? x.fx .speeds [e] || e: e, t = t || "fx", this.queue (t, função (t, n) {var r = setTimeout (t, e); n.stop = function () {clearTimeout (r)}})}, clearQueue: function (e) {retorna this.queue (e || "fx", [])}, promete: function (e, n) {var r, i = 1, o = x.Deferido (), a = isto, s = este.length, l = função () {- i || o.resolveWith (a, [a])}; "string"! = typeof e && (n = e, e = t), e = e || "fx", enquanto (s -) r = x._data (a [s], e + "queueHooks"), r && r.empty && (i ++, r.empty.add (l)); return l (), o.promise (n)}}); var z, X, U = / [\ t \ r \ n \ f] / g, V = / \ r / g, Y = / ^ (?: input | selecione | textarea | botão | objeto | $) / i, J = / ^ (? : a | area) $ / i, G = / ^ (?: marcado | selecionado) $ / i, Q = x.support.getSetAttribute, K = x.support.input; x.fn.extend ({attr: function (e, t) {retorna x.access (isto, x.attr, e, t, argumentos.length> 1)}, removeAttr: função (e) {retorna this.each (função () {x.removeAttr (isto , e)})}, prop: function (e, t) {return x.access (this, x.prop, e, t, argument.length> 1)}, removeProp: function (e) {return e = x .propFix [e] || e, this.each (function () {try {this [e] = t, exclua este [e]} catch (n) {}})}, addClass: function (e) {var t, n, r, i, o, a = 0, s = this.length, l = "string" == tipo de e&&; if (x.isFunction (e)) retorna this.each (function (t) {x (this) .addClass (e.call (this, t, this.className))}); if (l) for (t = (e || "").corresponde (T) || []; s> a; a ++) if (n = this [a], r = 1 === n.nodeType && (n.className? ("" + n.className + ""). (U, ""): "")) {o = 0; while (i = t [o ++]) 0> r.indexOf ("" + i + "") && (r + = i + ""); n.className = x.trim (r)} retorna isso}, removeClass: function (e) {var t, n, r, i, o, a = 0, s = this.length, l = 0 === argumentos.length | | "string" == tipo de e &&; if (x.isFunction (e)) retorna this.each (function (t) {x (this) .removeClass (e.call (this, t, this.className))}) ; if (l) para (t = (e || ""). match (T) || []; s> a; a ++) if (n = isto [a], r = 1 === n.nodeType && (n.className? ("" + n.className + ""). substitua (U, ""): "")) {o = 0; while (i = t [o ++]) while (r.indexOf ("" + i + "")> = 0) r = r.replace ("" + i + "", ""); n.className = e? x.trim (r): ""} retorne isso}, toggleClass: function (e, t) {var n = typeof e; retorne" boolean "== tipoof &&" string "=== n? t? this.addClass (e): this.removeClass ( e): x.isFunction (e)? this.each (function (n) {x (this) .toggleClass (e.call (isso, n, nome.classe, t), t)}): this.each ( function () {if ("string" === n) {var t, r = 0, o = x (this), a = e.match (T) || []; while (t = a [r ++] ) o.hasClass (t)? o.removeClass (t): o.addClass (t)} else (n === i || "booleano" === n) && (this.className && x._data (this, " __className __ ", this.className), this.className = this.className || e ===! 1?" ": x._data (este," __ className __ ") ||" ")})}, hasClass: function ( e) {var t = "" + e + "", n = 0, r = this.length; for (; r> n; n ++) if (1 === this [n] .nodeType && ("" + this [ n] .className + "") .replace (U, "") .indexOf (t)>= 0) return! 0; return! 1}, val: function (e) {var n, r, i, o = this [0]; {if (argument.length) retorna i = x.isFunção (e), this.each (function (n) {var o; 1 === this.nodeType && (o = i? e.call (this, n, x (this) .val ()): e, null == o? o = "": "number" == typeof o? o + = "": x.isArray (o) && (o = x.map (o, função (e) {return null == e? "": e + "" })), r = x.valHooks [this.type] || x.valHooks [this.nodeName.toLowerCase ()], r && "conjunto" em r && r.set (este, o, "valor")! == t || (this.value = o))}); if (o) retorna r = x.valHooks [o.type] || x.valHooks [o.nodeName.toLowerCase ()], r && "get" em r && ( n = r.get (o, "valor"))! == t? n: (n = o.value, "string" == tipo de n? n.replace (V, ""): null == n? "": n)}}}), x.extend ({valHooks: {option: {get: function (e) {var t = x.find.attr (e, "value"); retornar nulo! = t? t: e.texto}}, selecione: {get: function (e) {var t, n, r = e.options, i = e.selectedIndex, o = "select one" === e.type || 0> i, a = o? null: [], s = o? i + 1: r.length, l = 0> i? s: o? i: 0; para (; s> l; l ++) se (n = r [ l],! (! n.selecionado && l! == i || (x.support.optDisabled? n.disabled: null! == n.getAttribute ("disabled"))) || n.parentNode.disabled && x.nodeName (n .parentNode, "optgroup"))) {if (t = x (n) .val (), o) retorna t; a.push (t)} retorna a}, define: function (e, t) {var n , r, i = e.options, o = x.makeArray (t), a = i.length; while (a -) r = i [a], (r.selected = x.inArray (x (r)) .val (), o)> = 0) && (n =! 0); return n || (e.selectedIndex = -1), o}}}, attr: function (e, n, r) {var o , a, s = e.nodeType; if (e && 3! == s && 8! == s && 2! == s) retorna o tipo de e.getAttribute === i? x.prop (e, n, r) :( 1 == = s && x.isXMLDoc (e) || (n = n.toLowerCase (), o = x.attrHooks [n] || (x.expr.match.bool.test (n)? X: z)), r = == t? o && "get "in o && null! == (a = o.get (e, n))? a: (a = x.find.attr (e, n), null == a? t: a): null! == r? o && "define" em o && (a = o.set (e, r, n))! == t? a: (e.setAttribute (n, r + ""), r) :( x.removeAttr (e , n), t))}, removeAttr: function (e, t) {var n, r, i = 0, o = t && t.match (T); if (o && 1 === e.nodeType) while (n = o [i ++]) r = x.propFix [n] || n, x.expr.match.bool.test (n)? K && Q ||! G.test (n)? e [r] =! 1: e [x.camelCase ("padrão -" + n)] = e [r] =! 1: x.attr (e, n, ""), e.removeAttribute (Q? n: r)}, attrHooks: {type : {set: function (e, t) {if (! x.support.radioValue && "radio" === t && x.nodeName (e, "input")) {var n = e.value; retorne e.setAttribute (" tipo ", t), n && (e.value = n), t}}}}, propFix: {" for ":" htmlFor "," class ":" className "}, prop: function (e, n, r ) {var i, o, a, s = e.nodeType; if (e && 3!== s && 8! == s && 2! == s) retorne a = 1! == s ||! x.isXMLDoc (e), a && (n = x.propFix [n] || n, o = x.propHooks [ n]), r! == t? o && "set" em o && (i = o.set (e, r, n))! == t? i: e [n] = r: o && "get" em o && null ! == (i = o.get (e, n))? i: e [n]}, propHooks: {tabIndex: {get: function (e) {var t = x.find.attr (e, "tabindex "); return t? parseInt (t, 10): Y.test (e.nodeName) || J.test (e.nodeName) && e.href? 0: -1}}}}), X = {set: função (e, t, n) {retornar t ===! 1? x.removeAttr (e, n): K && Q ||! G.test (n)? e.setAttribute (! Q && x.propFix [n] || n, n): e [x.camelCase ("padrão -" + n)] = e [n] =! 0, n}}, x.each (x.expr.match.bool.source.match (/ \ w + / g), função (e, n) {var r = x.expr.attrHandle [n] || x.find.attr; x.expr.attrHandle [n] = K&&Q ||! G.test (n) Função? (e, n, i) {var o = x.expr.attrHandle [n], a = i? t: (x.expr.attrHandle [n] = t)! = r (e, n, i) ? n.toLowerCase (): null;return x.expr.attrHandle [n] = o, a}: function (e, n, r) {return r? t: e [x.camelCase ("padrão -" + n)]? n.toLowerCase (): null}}), K && Q || (x.attrHooks.value = {set: function (e, n, r) {retorna x.nodeName (e, "input")? (e.defaultValue = n, t): z && z .set (e, n, r)}}), Q || (z = {set: function (e, n, r) {vari = e.getAttributeNode (r); retorna i || e.setAttributeNode (i = e.ownerDocument.createAttribute (r)), valor i = n + = "", "valor" === r || n === e.getAttribute (r)? n: t}}, x.expr. attrHandle.id = x.expr.attrHandle.name = x.expr.attrHandle.coords = função (e, n, r) {var i; retorna r? t: (i = e.getAttributeNode (n)) && "" ! == i.value? i.value: null}, x.valHooks.button = {get: function (e, n) {var r = e.getAttributeNode (n); retorna r &&r.especificado? r.value: t }, defina: z.set}, x.attrHooks.contenteditable = {set: function (e, t, n) {z.set (e, "" === t?! 1: t, n)}}, x.each (["width "," height "], function (e, n) {x.attrHooks [n] = {set: function (e, r) {return" "=== r? (e.setAttribute (n," auto ") ), r): t}}})), x.support.hrefNormalizado || x.each (["href", "src"]], função (e, t) {x.propHooks [t] = {get: função (e) {retornar e.getAttribute (t, 4)}}}), x.support.style || (x.attrHooks.style = {obter: função (e) {retornar e.style.cssText || t }, defina: function (e, t) {retorne e.style.cssText = t + ""}}), x.support.optSelected || (x.propHooks.selected = {get: function (e) {var t = e.parentNode; return t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex), null}}), x.each (["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {x.propFix [this.toLowerCase ()] = this}), x.support.enctype || (x.propFix.enctype = "encoding"), x.each (["radio", "checkbox"], function () { x.valHooks [this] = {set: function (e, n) {return x.isArray (n)? e.checked = x.inArray (x (e) .val (), n)> = 0: t} } x.support.checkOn || (x.valHooks [this] .get = function (e) {return null === e.getAttribute ("value")? "on": e.value})}); var Z = / ^ (?: input | select | textarea) $ / i, et = / ^ key /, tt = / ^ (?: mouse | contextmenu) | click /, nt = / ^ (?: focusinfocus | focusoutblur ) $ /, rt = / ^ ([^.] *) (?: \. (. +) |) $ /; function it () {return! 0} função ot () {return! 1} função em ( ) {try {return a.activeElement} catch (e) {}} x.event = {global: {}, add: function (e, n, r, o, a) {var s, l, u, c, p, f, d, h, g, m, y, v = x._dados (e); if (v) {r.handler && (c = r, r = c.handler, a = c.seletor), r .guid || (r.guid = x.guid ++), (l = v.eventos) || (l = v.eventos = {}), (f = v.handle) || (f = v.handle = função (e) {tipo de retorno de x === i || e && x.event.triggered === e.type? t: x.event.dispatch.apply (f.elem, argumentos)}, f.elem = e), n = (n || ""). corresponde (T) || [""], u = n.length; enquanto (u -) s = rt.exec (n [u]) || [ ], g = y = s [1], m = (s [2] || ""). split ("."). sort (), g && (p = x.event.especial [g] || { }, g = (a? p.delegateType: p.bindType) || g, p = x.event.special [g] || {}, d = x.extend ({type: g, origType: y, data : o, manipulador: r, guid: r.guid, seletor: a, needsContext: a && x.expr.match.needsContext.test (a), espaço para nome: m.join (".")}, c), (h = l [g]) || (h = l [g] = [], h.delegateCount = 0, p.setup && p.setup.call (e, o, m, f)! ==! 1 || (e. addEventListener? e.addEventListener (g, f,! 1): e.attachEvent && e.attachEvent ("em" + g, f))), p.add && (p.add.call (e, d), d.handler. guid || (d.handler.guid = r.guid)), um? h.splice (h.delegateCount ++, 0, d): h.push (d), x.event.global [g] =! 0); e = nulo}}, remove: function (e, t, n, r, i) {var o, a, s, l, u, c, p, f, d, h , g, m = x.temDados (e) && x._dados (e); if (m && (c = m.eventos)) {t = (t || ""). match (T) || [""] , u = t.length; while (u -) if (s = rt.exec (t [u]) || [], d = g = s [1], h = (s [2] || " ") .split (". "). sort (), d) {p = x.event.especial [d] || {}, d = (r? p.delegateType: p.bindType) || d, f = c [d] || [], s = s [2] && RegExp ("(^ | \\.)" + h.join ("\\. (?:. * \\. |)") + " (\\. | $) "), l = o = f.length; while (o -) a = f [o] ,! i && g! == a.origType || n && n.guid! == a.guid || s &&! s.test (a.namespace) || r && r! == a.selector && ("**"! == r ||! a.selector) || (f.splice (o, 1), a .selector && f.delegateCount -, p.remove && p.remove.call (e, a)); l &&! f.length && (p.teardown && p.teardown.call (e, h, m.handle)! ==! 1 || x.removeEvent (e, d, m.handle),delete c [d])} else for (d em c) x.event.remove (e, d + t [u], n, r,! 0); x.isEmptyObject (c) && (delete m.handle, x._removeData (e, "events"))}}, trigger: function (n, r, i, o) {var s, l, u, c, p, f, d, h = [i || a] , g = v.call (n, "tipo")? n.type: n, m = v.call (n, "namespace")? n.namespace.split ("."): []; if (u = f = i = i || a, 3! == i.nodeType && 8! == i.nodeType &&! nt.test (g + x.event.triggered) && (g.indexOf (".")> = 0 && ( m = g.split ("."), g = m.shift (), m.sort ()), l = 0> g.indexOf (":") && "em" + g, n = n [x .expando]? n: new x.Event (g, "objeto" == tipo de n && n), n.isTrigger = o? 2: 3, n.namespace = m.join ("."), n.namespace_re = n RegExp ("(^ | \\.)" + m.join ("\\. (?:. * \\. |)") + "(\\. | $)"): nulo, n .result = t, n.target || (n.target = i), r = nulo == r? [n]: x.makeArray (r, [n]),p = x.event.special [g] || {}, o ||! p.trigger || p.trigger.apply (i, r)! ==! 1)) {if (! o &&! p.noBubble && ! x.isWindow (i)) {for (c = p.delegateType || g, nt.test (c + g) || (u = u.parentNode); u; u = u.parentNode) h.push ( u), f = u; f === (i.ownerDocument || a) && h.push (f.defaultView || f.parentWindow || e)} d = 0; while ((u = h [d ++]) &&! n.isPropagationStopped ()) n.type = d> 1? c: p.bindType || g, s = (x._dados (u, "eventos") || {}) [n.type] && x. _dados (u, "identificador"), s && s.apply (u, r), s = l && u [l], s && x.acceptData (u) && s.apply && s.apply (u, r) ===! 1 && n.preventDefault () ; if (n.type = g,! o &&! n.isDefaultPrevented () && (! p._default || p._default.apply (h.pop (), r) ===! 1) && x.acceptData (i ) && l && i [g] &&! x.isWindow (i)) {f = i [l], f && (i [l] = null), x.event.triggered = g; tente {i [g] ()} pegar (y) {} x.evento.acionado = t, f && (i [l] = f)} retorna n.result}}, despacha: function (e) {e = x.event.fix (e); var n, r, i, o, a, s = [], l = g.call (argumentos), u = (x._dados (isso, "eventos") || {}) [e.type] || [], c = x.event.special [ e.type] || {}; if (l [0] = e, e.delegateTarget = this,! c.preDispatch || c.preDispatch.call (this, e)! ==! 1) {s = x .event.handlers.call (this, e, u), n = 0; while ((o = s [n ++]) &&! e.isPropagationStopped ()) {e.currentTarget = o.elem, a = 0; while ((i = o.handlers [a ++]) &&! e.isImmediatePropagationStopped ()) (! e.namespace_re || e.namespace_re.test (i.namespace)) && (e.handleObj = i, e.data = i .data, r = ((x.event.special [i.origType] || {}). handle || i.handler) .apply (o.elem, l), r! == t && (e.result = r) ===! 1 && (e.preventDefault (), e.stopPropagation ()))} retornar c.postDispatch && c.postDispatch.call (this, e), e.result}}, manipuladores: function (e, n) {var r, i, o, a, s = [], l = n.delegateCount, u = e.destino; if (l && u.nodeType && (! e.button || "clique"! == e.type)) para (; u! = this; u = u.parentNode || this) if (1 === u. nodeType && (u.disabled! ==! 0 || "clique"! == e.type)) {for (o = [], a = 0; l> a; a ++) i = n [a], r = i.selector + "", o [r] === t && (o [r] = i.needsContext? x (r, this) .index (u)> = 0: x.find (r, this, null, [ u]). length), o [r] && o.push (i); o.length && s.push ({elem: u, manipuladores: o})} retorna n.length> l && s.push ({elem: this, manipuladores : n.slice (l)}), s}, corrige: function (e) {if (e [x.expando]) retorna e; var t, n, r, i = e.type, o = e, s = this.fixHooks [i]; s || (this.fixHooks [i] = s = tt.test (i)? this.mouseHooks: et.test (i)? this.keyHooks: {}), r = s .props? this.props.concat (s.props): this.props, e = new x.Event (o), t = r.length; while (t -) n = r [t], e [n ] = o [n]; retorna e.target || (e.target = o.srcElement || a), 3 === e.target.nodeType && (e.target = e.target.parentNode), e.metaKey = !! e.metaKey, s.filter? s.filter (e, o): e}, props: "altKey borbulha cancelável ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view what" .split (""), fixHooks: {}, keyHooks: {props: "char charCode key keyCode" .split (""), filter: function (e, t) {return null == e.which && (e.which = null! = t.charCode? t .charCode: t.keyCode), e}}, mouseHooks: {props: "button buttons clientX clientY fromElement offsetX offsetY páginaX páginaY screenX screenY toElement" .split (""), filter: function (e, n) {var r, i, o, s = n.botão, l = n.fromElement; return null == e.pageX && null! = n.clientX && (i = e.target.ownerDocument || a, o = i.documentElement, r = i. body, e.pageX = n.clienteX + (o && o.scrollLeft || r && r.scrollLeft || 0) - (o && o.clientLeft || r && r.clientLeft || 0), e.pageY = n.clientY + (o && o.scrollTop || r && r.scrollTop || 0) - (o && o.clientTop || r && r.clientTop || 0)) ,! e.relatedTarget && l && (e.relatedTarget = l === e.target?n.toElement : l), e.qual é || s === t || (e.qual = 1 & s? 1: 2 & s? 3: 4 & s? 2: 0), e}}, especial: {load: {noBubble:! 0 } foco: {trigger: function () {if (this! == at () && this.focus) tente {return this.focus () ,! 1} catch (e) {}}, delegateType: "focusin"} , desfoque: {trigger: function () {retorne = = em () && this.blur? (this.blur () ,! 1): t}, delegateType: "focusout"}, clique em: {trigger: function ( ) {return x.nodeName (this, "input") && "checkbox" === this.type && this.click? (this.click () ,! 1): t}, _ padrão: function (e) {return x. nodeName (e.target, "a")}}, antes da descarga: {postDispatch: function (e) {e.result! == t && (e.originalEvent.returnValue = e.result)}}},simular: função (e, t, n, r) {var i = x.extend (novo x.Event, n, {tipo: e, isSimulated:! 0, originalEvent: {}}); r? x.event. gatilho (i, nulo, t): x.event.dispatch.call (t, i), i.isDefaultPrevented () && n.preventDefault ()}}, x.removeEvent = a.removeEventListener? function (e, t, n ) {e.removeEventListener && e.removeEventListener (t, n,! 1)}: function (e, t, n) {var r = "on" + t; e.detachEvent && (tipo de e [r] === i && (e [r] = nulo), e.detachEvent (r, n))}, x.Evento = função (e, n) {retorna esta instância de x.Evento? (e && e.tipo? (este.Evento original = e, este. tipo = e.type, this.isDefaultPrevented = e.defaultPrevented || e.returnValue ===! 1 || e.getPreventDefault && e.getPreventDefault ()? it: ot): this.type = e, n && x.extend (this, n), this.timeStamp = e && e.timeStamp || x.now (), este [x.expando] =! 0, t): novo x.Event (e, n)}, x.Event.prototype = {isDefaultPrevented : ot,isPropagationStopped: ot, isImmediatePropagationStopped: ot, preventDefault: function () {var e = this.originalEvent; this.isDefaultPrevented = it, e && (e.preventDefault? e.preventDefault (): e.retevValue =! 1)} function () {var e = this.originalEvent; this.isPropagationStopped = it, e && (e.stopPropagation && e.stopPropagation (), e.cancelBubble =! 0)}, stopImmediatePropagation: function () {this.isImmediatePropagationStopped. stopPropagation ()}}, x.each ({mouseenter: "mouseover", mouse: "mouseout"}, função (e, t) {x.event.special [e] = {delegateType: t, bindType: t, handle : function (e) {var n, r = this, i = e.relatedTarget, o = e.handleObj; return (! i || i! == r &&! x.contains (r, i)) && (e. tipo = o.origType, n = o.handler.apply (isso, argumentos), e.type = t), n}}}), x.support.submitBubbles || (x.event.special.submit = {setup : function () {retornar x.nodeName (this, "form") ?! 1: (x.event.add (this, "click._submit keypress._submit", função (e) {var n = e.target, r = x.nodeName (n, "input") || x.nodeName (n, "button")? n.form: t; r &&! x._data (r, "submitBubbles") && (x.event.add (r, "submit._submit") , function (e) {e._submit_bubble =! 0}), x._dados (r, "submitBubbles",! 0))}), t)}, postDispatch: function (e) {e._submit_bubble && (excluir e. _submit_bubble, this.parentNode &&! e.isTrigger && x.event.simulate ("submit", this.parentNode, e,! 0))}, teardown: function () {return x.nodeName (this, "form") ?! 1 : (x.event.remove (this, "._ submit"), t)}}), x.support.changeBubbles || (x.event.special.change = {setup: function () {retorne Z.test ( this.nodeName)? (("caixa de seleção" === this.type || "radio" === this.type) && (x.event.add (this, "propertychange._change", function (e) {"selected" === e.originalEvent.propertyName && (this.just_changed =! 0)}), x.event.add (this, "click._change" , função (e) {this._just_changed &&! e.isTrigger && (this._just_changed =! 1), x.event.simulate ("change", this, e,! 0)})) ,! 1) :( x. event.add (isto, "antes de ativar._ alteração", função (e) {var t = e.target; Z.test (t.nodeName) &&! x._data (t, "changeBubbles") && (x.event. add (t, "change._change", function (e) {! this.parentNode || e.isSimulated || e.isTrigger || x.event.simulate ("change", this.parentNode, e,! 0) }), x._dados (t, "changeBubbles",! 0))}), t)}, manipulador: function (e) {var n = e.target; retorna isso! == n || e.isSimulated | | e.isTrigger || "radio"! == n.type && "checkbox"! == n.type? e.handleObj.handler.apply (this, argument): t}, teardown: function () {return x.event.remove (this, "._ change") ,! Z.test (this.nodeName)}}), x.support.focusinBubbles | | x.each ({focus: "focusin", blur: "focusout"}, função (e, t) {var n = 0, r = function (e) {x.event.simulate (t, e.target, x.event.fix (e) ,! 0)}; x.event.special [t] = {setup: function () {0 === n ++ && a.addEventListener (e, r,! 0)}, teardown: function () {0 === - n && a.removeEventListener (e, r,! 0)}}}), x.fn.extend ({on: function (e, n, r, i, o) { var a, s; if ("objeto" == tipo de e) {"string"! = tipo de n && (r = r || n, n = t); para (a em e) isso. em (a, n, r, e [a], o); retorne} se (null == r && null == i? (i = n, r = n = t): null == i && ("string" == typeof n? (i = r, r = t) :( i = r, r = n, n = t)), i ===! 1) i = ot; caso contrário, se (! i) retornar isso; retornar 1 === o && ( s = i, i = função (e) {retorna x (). off (e), s.apply (isto, argumentos)}, i.guid = s.guid || (s.guid = x.guid ++)), this.each (function () {x.event.add (this, e, i, r, n)})}, one: function (e, t, n, r) {retorna this.on (e, t, n, r, 1)}, off: function (e, n, r) {var i, o; if (e && e.preventDefault && e.handleObj) return i = e .handleObj, x (e.delegateTarget) .off (i.namespace? i.origType + "." + i.namespace: i.origType, i.selector, i.handler), este; if ("object" == typeof e) {para (o em e) this.off (o, n, e [o]); retorna este} retorno (n ===! 1 || "função" == tipo de n) && (r = n, n = t), r ===! 1 && (r = ot), this.each (function () {x.event.remove (this, e, r, n)})}, trigger: function (e, t ) {return this.each (function () {x.event.trigger (e, t, this)})}, triggerHandler: function (e, n) {var r = this [0]; return r? x.event .trigger (e, n, r,! 0): t}}); var st = / ^. [^: # \ [\.,] * $ /, lt = / ^ (?: pais | prev (? : Até | Todos)) /, ut = x.expr.match.needsContext, ct = {filhos:! 0, conteúdo:! 0, próximo:! 0, prev:! 0}; x.fn.extend ({find: function (e) {var t, n = [], r = this, i = r.length; if ("string"! = typeof e) retorna this.pushStack (x (e) .filter ( function () {for (t = 0; i> t; t ++) if (x.contains (r [t], this)) return! 0})); for (t = 0; i> t; t ++) x .find (e, r [t], n); return n = this.pushStack (i> 1? x.unique (n): n), n.selector = this.selector? this.selector + "" + e: e, n}, possui: function (e) {var t, n = x (e, this), r = n.length; retorna this.filter (function () {para (t = 0; r> t; t ++ ) if (x.contains (this, n [t])) return! 0})}, not: function (e) {return this.pushStack (ft (this, e || [] ,! 0))}, filter: function (e) {return this.pushStack (ft (this, e || [] ,! 1))}, é: function (e) {return !! ft (this, "string" == typeof e && ut. teste (e)? x (e): e || [] ,! 1) .length}, mais próximo: function (e, t) {var n, r = 0, i = this.length, o = [], a = ut.test (e) || "string"! = tipo de e? x (e, t || this.context): 0; for (; i> r; r ++) for (n = this [r]; n && n! == t; n = n.parentNode) if (11> n.nodeType && (a? a.index (n)> - 1: 1 === n.nodeType && x.find.matchesSelector (n, e))) {n = o.push (n); break} retorna this.pushStack (o.length> 1? x.unique (o): o)}, índice: function (e) {return e? "string" == tipo de e? x.inArray (this [0] , x (e)): x.inArray (e.jquery? e [0]: e, this): this [0] && this [0] .parentNode? this.first (). prevAll (). length: -1 }, adicione: function (e, t) {var n = "string" == tipo de e? x (e, t): x.makeArray (e && e.nodeType? [e]: e), r = x.merge ( (); return this.pushStack (x.unique (r))}, addBack: function (e) {retorna this.add (null == e? this.prevObject: this.prevObject.filter ( e))}}); função pt (e, t) {do e = e [t]; while (e && 1! == e.nodeType); return e} x.each ({parent: function (e) {var t = e.parentNode; return t && 11! == t.nodeType? t: null}, parent: function (e) {return x.dir (e, "parentNode")}, parentUntil: function (e, t,n) {return x.dir (e, "parentNode", n)}, próximo: function (e) {return pt (e, "nextSibling")}, prev: function (e) {return pt (e, "previousSibling ")}, nextAll: function (e) {return x.dir (e," nextSibling ")}, prevAll: function (e) {return x.dir (e," previousSibling ")}, nextUntil: function (e, t, n) {return x.dir (e, "nextSibling", n)}, prevUntil: function (e, t, n) {return x.dir (e, "previousSibling", n)}, irmãos: function ( e) {return x.sibling ((e.parentNode || {}). firstChild, e)}, filhos: função (e) {return x.sibling (e.firstChild)}, conteúdo: function (e) {return x.nodeName (e, "iframe")? e.contentDocument || e.contentWindow.document: x.merge ([], e.childNodes)}}, função (e, t) {x.fn [e] = function (n, r) {var i = x.map (this, t, n); return "Até"! == e.slice (-5) && (r = n), r && "string" == tipo de r && (i = x.filtro (r,i)), this.length> 1 && (ct [e] || (i = x.unique (i)), lt.test (e) && (i = i.reverse ())), this.pushStack (i )}}), x.extend ({filter: function (e, t, n) {var r = t [0]; retorna n && (e = ": not (" + e + ")"), 1 === t.length && 1 === r.nodeType? x.find.matchesSelector (r, e)? [r]: []: x.find.matches (e, x.grep (t, função (e) {return 1 = == e.nodeType}))}, dir: function (e, n, r) {vari = [], o = e [n]; while (o && 9! == o.nodeType && (r === t | | 1! == o.nodeType ||! X (o) .is (r))) 1 === o.nodeType && i.push (o), o = o [n]; return i}, irmão i: function ( e, t) {var n = []; para (; e; e = e.nextSibling) 1 === tipo e.node && e! == t && n.push (e); retorno n}}); função ft (e, t, n) {if (x.isFunction (t)) retorna x.grep (e, function (e, r) {return !! t.call (e, r, e)! == n}); if ( t.nodeType) return x.grep (e, função (e) {return e === t! == n}); if ("string" == tipo de t) {if (st.test (t)) return x.filtro (t, e, n); t = x.filter (t, e)} return x.grep (e, function (e) {return x.inArray (e, t)> = 0! == n})} function dt (e) {var t = ht.split ("|"), n = e.createDocumentFragment (); if (n.createElement) while (t.length) n.createElement (t.pop ()); retorno n} var ht = "abbr | article | aparte | áudio | bdi | tela | dados | lista de dados | detalhes | figcaption | figura | rodapé | cabeçalho | hgroup | marca | medidor | nav | saída | progresso | seção | resumo | tempo | vídeo ", gt = / jQuery \ d + =" ( ?: null | \ d +) "/ g, mt = RegExp (" <(?: "+ ht +") [\\ s />] "," i "), yt = / ^ \ s + /, vt = / <(?! area | br | col | embed | hr | img | input | link | meta | param) (([\ w:] +) [^>] *) \ /> / gi, bt = / <( [\ w:] +) /, xt = / <tbody / i, wt = / <| & #? \ w +; /, Tt = / <(?: script | estilo | link) / i, Ct = / ^ (?: caixa de seleção | rádio) $ / i, Nt = / marcado \ s * (?: [^ =] | = \ s *. verificado.) / i, kt = / ^ $ | \ / (?: java | ecma) script / i, Et = / ^ true \ / (. *) /, St = / ^ \ s * <! (?: \ [CDATA \ [| -) | (?: \] \] | - -)> \ s * $ / g,Em = {opção: [1, "<selecione múltiplo = 'múltiplo'>", "</select>"], legenda: [1, "<fieldset>", "</fieldset>"], área: [1 , "<map>", "</map>"], param: [1, "<object>", "</object>"], thead: [1, "<table>", "</table> "], tr: [2," <table> <tbody> "," </tbody> </table> "], col: [2," <table> <tbody> </tbody> <colgroup> ", "</colgroup> </table>"], td: [3, "<table> <tbody> <tr>", "</tr> </tbody> </table>"], _ padrão: x.support .htmlSerialize? [0, "", ""]: [1, "X <div>", "</div>"]}, jt = dt (a), Dt = jt.appendChild (a.createElement (" div "));optgroup = At.option, At.tbody = At.tfoot = At.colgroup = At.caption = At.thead, At.th = At.td, x.fn.extend ({text: function (e) {return x .access (this, function (e) {return e === t? x.text (this): this.empty (). append ((this [0] && this [0] .ownerDocument || a) .createTextNode ( e))}, null, e, argument.length)}, anexa: function () {retorna this.domManip (argumentos, função (e) {if (1 === this.nodeType || 11 === this). nodeType || 9 === this.nodeType) {var t = Lt (isto, e); t.appendChild (e)}})}, prefixo: function () {retorna this.domManip (argumentos, função (e) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var t = Lt (this, e); t.insertBefore (e, t.firstChild) }})}, antes de: function () {retornar this.domManip (argumentos, função (e) {this.parentNode && this.parentNode.insertBefore (e, this)})}, depois de: function () {return this.domManip ( argumentos, função (e) {this.parentNode && this.parentNode.insertBefore (e,this.nextSibling)})}, remove: function (e, t) {var n, r = e? x.filter (e, isto): isto, i = 0; para (; null! = (n = r [ i]); i ++) t || 1! == n.nodeType || x.cleanData (Ft (n)), n.parentNode && (t && x.contains (n.ownerDocument, n) && _ t (script Ft (n, " ")), n.parentNode.removeChild (n)); retorne isso}, vazio: function () {var e, t = 0; para (; null! = (e = this [t]); t ++) {1 === e.nodeType && x.cleanData (Ft (e,! 1)); while (e.firstChild) e.removeChild (e.firstChild); e.options && x.nodeName (e, "select") && (e.options .length = 0)} retorne isso}, clone: ​​function (e, t) {retorne e = null == e?! 1: e, t = null == t? e: t, this.map (function () {return x.clone (this, e, t)})}, html: function (e) {return x.access (this, function (e) {var n = this [0] || {}, r = 0 , i = this.length; if (e === t) retorna 1 === n.nodeType? n.innerHTML.replace (gt, ""): t; if (! ("string"! = typeof e | | Tt.test (e) ||! X.support.htmlSerialize && mt.test (e) ||! x.support.leadingWhitespace && yt.test (e) || Em [(bt.exec (e) || ["", ""]) [1] .toLowerCase ()])) {e = e.replace (vt, "<$ 1> </ $ 2>"); tente {for (; i> r; r ++) n = este [r] || {}, 1 === n.nodeType && ( x.cleanData (Ft (n,! 1)), n.innerHTML = e); n = 0} catch (o) {}} n && this.empty (). append (e)}, null, e, argument.length )}, replaceWith: function () {var e = x.map (esta função (e) {return [e.nextSibling, e.parentNode]}), t = 0; retorne this.domManip (argumentos, função (n ) {var r = e [t ++], i = e [t ++]; i && (r && r.parentNode! == i && (r = this.nextSibling), x (this) .remove (), i.insertBefore (n, r ))}}, 0), t? This: this.remove ()}, desanexa: function (e) {retorna this.remove (e,! 0)}, domManip: function (e, t, n) {e = d.apply ([], e); var r, i, o, a, s, l, u = 0, c = this.length, p = this, f = c-1, h = e [0] , g = x.isFunção (h); if (g ||! (1> = c || "string"!= typeof h || x.support.checkClone) && Nt.test (h)) retorna this.each (function (r) {var i = p.eq (r); g&& (e [0] = h.call (este , r, i.html ())), i.domManip (e, t, n)}); if (c && (l = x.buildFragment (e, este [0] .ownerDocument,! 1,! n && this), r = l.firstChild, 1 === l.childNodes.length && (l = r), r)) {for (a = x.map (Ft (l, "script"), Ht), o = a.length ; c> u; u ++) i = l, u! == f && (i = x.clone (i,! 0,! 0), o && x.merge (a, Ft (i, "script"))), t .call (this [u], i, u); if (o) for (s = a [a.length-1] .ownerDocument, x.map (a, qt), u = 0; o> u; u ++ ) i = a [u], kt.test (i.type || "") &&! x._data (i, "globalEval") && x.contains (s, i) && (i.src? x._evalUrl ( i.src): x.globalEval ((i.text || i.textContent || i.innerHTML || ""). replace (St, ""))); l = r = null} retorne isso}}) ; função Lt (e, t) {retornar x.nodeName (e, "tabela") && x.nodeName (1 === t.nodeType? t: t.firstChild, "tr")? e.getElementsByTagName ("tbody") [0] || e.appendChild (e.ownerDocument.createElement ("tbody")): e} função Ht (e) {retornar e.type = (nulo! == x.find.attr (e, "tipo")) + "/" + e.type, e} função qt (e) {var t = Et.exec (e.type); return t? E.type = t [1]: e.removeAttribute ("tipo"), e} função _t (e, t) {var n, r = 0; for ( ; null! = (n = e [r]); r ++) x._data (n, "globalEval",! t || x._data (t [r], "globalEval"))}} função Mt (e, t ) {if (1 === t.nodeType && x.hasData (e)) {var n, r, i, o = x._dados (e), a = x._dados (t, o), s = o.events ; if (s) {delete a.handle, a.events = {}; for (n in s) for (r = 0, i = s [n] .length; i> r; r ++) x.event.add (t, n, s [n] [r])} a.data && (a.data = x.extend ({}, a.data))}}} função Ot (e, t) {var n, r, i ; if (1 === t.nodeType) {if (n = t.nodeName.toLowerCase () ,! x.support.noCloneEvent && t [x.expando]) {i = x._dados (t); para (r em i.events) x.removeEvent (t, r, i.handle); t.removeAttribute (x.expando)} "script" === n && t .text! == e.text? (Ht (t) .text = e.text, qt (t)): "objeto" === n? (t.parentNode && (t.outerHTML = e.outerHTML), x .support.html5Clone && e.innerHTML &&! x.trim (t.innerHTML) && (t.innerHTML = e.innerHTML)): "input" === n && Ct.test (e.type)? (t.defaultChecked = t.checked = e.checked, t.value! == e.value && (t.value = e.value)): "opção" === n? t.defaultSelected = t.selected = e.defaultSelected :( "input" = == n || "textarea" === n) && (t.defaultValue = e.defaultValue)}} x.each ({appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith"}, função (e, t) {x.fn [e] = função (e) {var n, r = 0, i = [],o = x (e), a = o.length-1; para (; a> = r; r ++) n = r === a? this: this.clone (! 0), x (o [r]) [t] (n), h.apply (i, n.get ()); retorna this.pushStack (i)}}); função Ft (e, n) {var r, o, a = 0, s = tipo de e.getElementsByTagName! == i? e.getElementsByTagName (n || "*"): tipo de e.querySelectorAll! == i? e.querySelectorAll (n || "*"): t; if (! s) para (s = [], r = e.childNodes || e; null! = (o = r [a]); a ++)! n || x.nodeName (o, n)? s.push (o): x .merge (s, Ft (o, n)); return n === t || n && x.nodeName (e, n)? x.merge ([e], s): s} função Bt (e) {Ct .test (e.type) && (e.defaultChecked = e.checked)} x.extend ({clone: ​​function (e, t, n) {var r, i, o, a, s, l = x.contains (e.ownerDocument, e); if (x.support.html5Clone || x.isXMLDoc (e) ||! mt.test ("<" + e.nodeName + ">")? o = e.cloneNode (! 0 ) :( Dt.innerHTML = e.outerHTML, Dt.removeChild (o = Dt.firstChild)),! (X.support.noCloneEvent && x.support.noCloneChecked || 1! == e.nodeType && 11! == e.nodeType || x.isXMLDoc (e))) para (r = Ft (o), s = Ft (e), a = 0; nulo! = (I = s [a]); + + a) r [a] && Ot (i, r [a]); se (t) se (n) para (s = s || Ft (e), r = r || Ft (o), a = 0 ; null! = (i = s [a]); a ++) Mt (i, r [a]); else Mt (e, o); return r = Ft (o, "script"), r.length> 0 && t (r,! l && Ft (e, "script")), r = s = i = nulo, o}, buildFragment: function (e, t, n, r) {var i, o, a, s, l, u , c, p = e.length, f = dt (t), d = [], h = 0; para (; p> h; h ++) se (o = e [h], o || 0 === o) if ("objeto" === x.type (o)) x.merge (d, o.nodeType? [o]: o); caso contrário, if (wt.test (o)) {s = s || f.appendChild (t.createElement ("div")), l = (bt.exec (o) || ["", ""]) [1] .toLowerCase (), c = At ​​[l] || At ._default, s.innerHTML = c [1] + o.replace (vt, "<$ 1> </ $ 2>") + c [2], i = c [0]; enquanto (i -) s = s .lastChild; if (! x.support.leadingWhitespace && yt.test (o) && d.push (t.createTextNode (yt.exec (o) [0])) ,! x.support.tbody) {o = "tabela "! == l || xt.test (o)?" <tabela> "! == c [1] || xt.test (o)? 0: s: s.firstChild, i = o && o.childNodes. length; while (i -) x.nodeName (u = o.childNodes [i], "tbody") &&! u.childNodes.length && o.removeChild (u)} x.merge (d, s.childNodes), s .textContent = ""; while (s.firstChild) s.removeChild (s.firstChild); s = f.lastChild} else d.push (t.createTextNode (o)); s && f.removeChild (s), x.support .appendChecked || x.grep (Ft (d, "entrada"), Bt), h = 0; while (o = d [h ++]) if ((! r || -1 === x.inArray (o , r)) && (a = x.contains (o.ownerDocument, o), s = Ft (f.appendChild (o), "script"), a && _t (s), n)) {i = 0; while ( o = s [i ++]) kt.test (o.type || "") && n.push (o)} retorna s = nulo, f}, cleanData: function (e, t) {var n, r, o, a, s = 0, l = x.expando, u = x.cache, c = x.support.deleteExpando, f = x.event.special; for (; null! = (n = e [s]); s ++ ) se ((t || x.acceptData (n)) && (o = n [l], a = o && u [o])) {if (a.events) for (r in a.events) f [r]? x.event.remove (n, r): x.removeEvent (n, r, a.handle);
u [o] && (excluir u [o], c? excluir n [l]: tipo de n.removeAttribute! == i? n.removeAttribute (l): n [l] = nulo, p. push (o)) }}, _ evalUrl: function (e) {return x.ajax ({url: e, tipo: "GET", dataType: "script", assíncrono:! 1, global:! 1, "throws":! 0}) }}), x.fn.extend ({wrapAll: function (e) {if (x.isFunction (e)) retorna this.each (function (t) {x (this) .wrapAll (e.call (this, t))}); if (this [0]) {var t = x (e, this [0] .ownerDocument) .eq (0) .clone (! 0); this [0] .parentNode && t.insertBefore (this [0]), t.map (function () {var e = this; while (e.firstChild && 1 === e.firstChild.nodeType) e = e.firstChild; return e}). Append (this)} retorne isso }, wrapInner: function (e) {return x.isFunction (e)? this.each (function (t) {x (this) .wrapInner (e.call (this, t))}): this.each (function () {var t = x (this), n = t.contents (); n.length? n.wrapAll (e): t.append (e)})}, wrap: function (e) {var t = x.isFunction (e); retorne isso.each (function (n) {x (this) .wrapAll (t? e.call (this, n): e)})}, desembrulhe: function () {retorna this.parent (). each (function () { x.nodeName (this, "body") || x (this) .replaceWith (this.childNodes)}). end ()}}); var Pt, Rt, Wt, $ t = / alpha \ ([^) ] * \) / i, = = opacidade \ s * = \ s * ([^)] *) /, zt = / ^ (superior | direita | inferior | esquerda) $ /, Xt = / ^ (nenhuma | tabela (?! - c [ea]). +) /, Ut = / ^ margem /, Vt = RegExp ("^ (" + w + ") (. *) $", "i"), Yt = RegExp ( "^ (" + w + ") (?! px) [az%] + $", "i"), Jt = RegExp ("^ ([+ -]) = (" + w + ")", "i" ), Gt = {CORPO: "bloco"}, Qt = {posição: "absoluto", visibilidade: "oculto", exibição: "bloco"}, Kt = {letterSpacing: 0, fontWeight: 4end ()}}); var Pt, Rt, Wt, $ t = / alpha \ ([^)] * \) / i, = = opacidade \ s * = \ s * ([^)] *) / , zt = / ^ (superior | direita | inferior | esquerda) $ /, Xt = / ^ (nenhuma | tabela (?! - c [ea]). +) /, Ut = / ^ margem /, Vt = RegExp ( "^ (" + w + ") (. *) $", "i"), Yt = RegExp ("^ (" + w + ") (?! px) [az%] + $", "i"), Jt = RegExp ("^ ([+ -]) = (" + w + ")", "i"), Gt = {CORPO: "bloco"}, Qt = {posição: "absoluto", visibilidade: "oculto" , exibição: "bloco"}, Kt = {letterSpacing: 0, fontWeight: 4end ()}}); var Pt, Rt, Wt, $ t = / alpha \ ([^)] * \) / i, = = opacidade \ s * = \ s * ([^)] *) / , zt = / ^ (superior | direita | inferior | esquerda) $ /, Xt = / ^ (nenhuma | tabela (?! - c [ea]). +) /, Ut = / ^ margem /, Vt = RegExp ( "^ (" + w + ") (. *) $", "i"), Yt = RegExp ("^ (" + w + ") (?! px) [az%] + $", "i"), Jt = RegExp ("^ ([+ -]) = (" + w + ")", "i"), Gt = {CORPO: "bloco"}, Qt = {posição: "absoluto", visibilidade: "oculto" , exibição: "bloco"}, Kt = {letterSpacing: 0, fontWeight: 4Qt = {posição: "absoluta", visibilidade: "oculto", exibição: "bloco"}, Kt = {letterSpacing: 0, fontWeight: 4Qt = {posição: "absoluta", visibilidade: "oculto", exibição: "bloco"}, Kt = {letterSpacing: 0, fontWeight: 400}, Zt = ["Superior", "Direita", "Inferior", "Esquerda"], en = ["Webkit", "O", "Moz", "ms"]; função tn (e, t) (if (t em e) retorna t; var n = t.charAt (0) .toUpperCase () + t.slice (1), r = t, i = en.length; while (i -) if (t = en [i] + n, t em e) retorna t; retorna r} função nn (e, t) {retorna e = t || e, "nenhum" === x.css (e, "display") ||! x.contains (e.ownerDocument, e)} função rn (e, t) {var n, r, i, o = [], a = 0, s = e.length; for (; s> a ; a ++) r = e [a], r.style && (o [a] = x._dados (r, "exibição antiga"), n = r.style.display, t? (o [a] || "nenhuma" ! == n || (r.style.display = ""), "" === r.style.display && nn (r) && (o [a] = x._dados (r, "exibição antiga", ln (r .nodeName)))): o [a] || (i = nn (r), (n && "nenhum"! == n ||! i) && x._data (r, "exibição antiga", i? n: x .css (r, "exibição")))); para (a = 0;s> a; a ++) r = e [a], r.style && (t && "none"! == r.style.display && ""! == r.style.display || (r.style.display = t? o [a] || "": "none")); return e} x.fn.extend ({css: function (e, n) {return x.access (this, function (e, n, r) { var i, o, a = {}, s = 0; if (x.isArray (n)) {for (o = Rt (e), i = n.length; i> s; s ++) a [n [s ]] = x.css (e, n [s] ,! 1, o); retorna a} retorna r! == t? x.style (e, n, r): x.css (e, n)} , e, n, argumentos.length> 1)}, show: function () {return rn (this,! 0)}, hide: function () {return rn (this)}, alterna: function (e) {return "booleano" == tipo de e? e? this.show (): this.hide (): this.each (function () {nn (this)? x (this) .show (): x (this) .hide ()})}}), x.extend ({cssHooks: {opacidade: {get: function (e, t) {if (t) {var n = Wt (e, "opacidade"); return "" == = n? "1": n}}}}, cssNumber: {columnCount:! 0, fillOpacity:! 0, fontWeight:! 0, lineHeight:! 0, opacidade:! 0, ordem :!0, órfãos:! 0, viúvas:! 0, zIndex:! 0, zoom:! 0}, cssProps: {"float": x.support.cssFloat? "CssFloat": "styleFloat"}, estilo: function (e , n, r, i) {if (e && 3! == e.nodeType && 8! == e.nodeType && e.style) {var o, a, s, l = x.camelCase (n), u = e.style; if (n = x.cssProps [l] || (x.cssProps [l] = tn (u, l)), s = x.cssHooks [n] || x.cssHooks [l], r === t) return s && "get" em s && (o = s.get (e,! 1, i))! == t? o: u [n]; if (a = typeof r, "string" === a && (o = Jt.exec (r)) && (r = (o [1] +1) * o [2] + parseFloat (x.css (e, n)), a = "número"),! (Null == r || "número" === a && isNaN (r) || ("número"! == a || x.cssNúmero [l] || (r + = "px"), x.support.clearCloneStyle || " ! == r || 0! == n.indexOf ("plano de fundo") || (u [n] = "herdar"), s && "conjunto" em s && (r = s.set (e, r,i)) === t))) tente {u [n] = r} captura (c) {}}}, css: function (e, n, r, i) {var o, a, s, l = x.camelCase (n); return n = x.cssProps [l] || (x.cssProps [l] = tn (e.style, l)), s = x.cssHooks [n] || x.cssHooks [ l], s && "obtém" em s && (a = s.get (e,! 0, r)), a === t && (a = Wt (e, n, i)), "normal" === a && n em Kt && (a = Kt [n]), "" === r || r? (o = parseFloat (a), r ===! 0 || x.isNumeric (o)? o || 0: a ): a}}), e.getComputedStyle? (Rt = função (t) {retornar e.getComputedStyle (t, nulo)}, Wt = função (e, n, r) {var i, o, a, s = r || Rt (e), l = s? s.getPropertyValue (n) || s [n]: t, u = e.style; retorne s && (""! == l || x.contains (e. ownerDocument, e) || (l = x.style (e, n)), Yt.test (l) && Ut.test (n) && (i = u.width, o = u.minWidth, a = u.maxWidth , u.minWidth = u.maxWidth = u.width = l, l = s.width, u.width = i, u.minWidth = o, u.maxWidth = a)), l}): a.documentElement.currentStyle && (Rt = função (e) {retornar e.currentStyle}, Wt = função (e, n, r) {var i, o, a, s = r || Rt (e), l = s? s [n]: t, u = e.style; return null == l && u && u [n] && (l = u [n]), Yt.test (l) &&! zt.test (n) && (i = u.left, o = e.runtimeStyle, a = o && o.left, a && (o.left = e.currentStyle.left), u.left = "fontSize" === n? "1em": l, l = u.pixelLeft + "px", u.left = i, a && (o. left = a)), "" === l? "auto": l}); função on (e, t, n) {var r = Vt.exec (t); retorno r? Math.max (0, r [1] - (n || 0)) + (r [2] || "px"): t} função an (e, t, n, r, i) {var o = n === (r ? "border": "content")? 4: "width" === t? 1: 0, a = 0; para (; 4> o; o + = 2) "margem" === n && (a + = x .css (e, n + Zt [o] ,! 0, i)), r? ("conteúdo" === n && (a- = x.css (e, "preenchimento" + Zt [o] ,! 0 , i)), "margem"! == n && (a- = x.css (e, "borda" + Zt [o] + "Largura",! 0,i))) :( a + = x.css (e, "preenchimento" + Zt [o] ,! 0, i), "preenchimento"! == n && (a + = x.css (e, "borda" + Zt [o] + "Width",! 0, i))); retorna a} função sn (e, t, n) {var r =! 0, i = "width" === t? e.offsetWidth: e .offsetHeight, o = Rt (e), a = x.support.boxSizing && "border-box" === x.css (e, "boxSizing",! 1, o); if (0> = i || null == i) {if (i = Wt (e, t, o), (0> i || null == i) && (i = e.style [t]), Yt.test (i)) retorna i ; r = a && (x.support.boxSizingReliable || i === e.style [t]), i = parseFloat (i) || 0} retorna i + an (e, t, n || (a? " borda ":" conteúdo "), r, o) +" px "} função ln (e) {var t = a, n = Gt [e]; retorno n || (n = un (e, t)," nenhum "! == n && n || (Pt = (Pt || x (" <iframe frameborder = '0' width = '0' width = '0' height = '0' /> ").) css (" cssText "," display: block ! important ")). appendTo (t.documentElement), t = (Pt [0] .contentWindow || Pt [0] .contentDocument) .documento, t.write ("<! doctype html> <html> <body>"), t.close (), n = un (e, t), Pt.detach ()), Gt [e] = n), n} função un (e, t) {var n = x (t.createElement (e)). appendTo (t. corpo), r = x.css (n [0], "exibição"); retorna n.remove (), r} x.each (["altura", "largura"], função (e, n) {x .cssHooks [n] = {get: function (e, r, i) {return r? 0 === e.offsetWidth && Xt.test (x.css (e, "exibição"))? x.swap (e, Qt , função () {retornar sn (e, n, i)}): sn (e, n, i): t}, definir: função (e, t, r) {var i = r && Rt (e); retornar em (e, t, r? an (e, n, r, x.support.boxSizing && "border-box" === x.css (e, "boxSizing",! 1, i), i): 0)} }}), x.support.opacity || (x.cssHooks.opacity = {get: function (e, t) {retorna It.test ((t && e.currentStyle? e.currentStyle.filter: e.style.filter)) || "")?01 * parseFloat (RegExp. $ 1) + "": t? "1": ""}, conjunto: função (e, t) {var n = e.style, r = e.currentStyle, i = x.isNumeric ( t)? "alpha (opacidade =" + 100 * t + ")": "", o = r && r.filter || n.filter || ""; n.zoom = 1, (t> = 1 || "" === t) && "" === x.trim (o.replace ($ t, "")) && n.removeAttribute && (n.removeAttribute ("filter") "," === t || r &&! r .filter) || (n.filter = $ t.test (o)? o.replace ($ t, i): o + "" + i)}}), x (function () {x.support.reliableMarginRight | | (x.cssHooks.marginRight = {get: function (e, n) {retorna n? x.swap (e, {display: "inline-block"}, Wt, [e, "marginRight"]): t} }) ,! x.support.pixelPosition && x.fn.position && x.each (["top", "left"]], função (e, n) {x.cssHooks [n] = {get: function (e, r) { retornar r? (r = Wt (e, n), Yt.teste (r)? x (e) .position () [n] + "px": r): t}}})}), x.expr && x.expr.filters && (x.expr.filters.hidden = function ( e) {return 0> = e.offsetWidth && 0> = e.offsetHeight ||! x.support.reliableHiddenOffsets && "none" === (e.style && e.style.display || x.css (e, "exibição")) } x.expr.filters.visible = function (e) {return! x.expr.filters.hidden (e)}), x.each ({margin: "", padding: "", border: "Width" }, função (e, t) {x.cssHooks [e + t] = {expand: function (n) {var r = 0, i = {}, o = "string" == tipo de n? n.split ( ""): [n]; para (; 4> r; r ++) i [e + Zt [r] + t] = o [r] || o [r-2] || o [0]; retorno i }}, Teste.teste (e) || (x.cssHooks [e + t] .set = on)}); var cn = /% 20 / g, pn = / \ [\] $ /, fn = / \ r? \ n / g, dn = / ^ (?: enviar | botão | imagem | redefinir | arquivo) $ / i, hn = / ^ (?: entrada | selecionar | textarea | keygen) /i;x.fn .extend ({serialize: function () {return x.param (this.serializeArray ())}, serializeArray: function () {retorna this.map (function () {var e = x.prop (this, "elements"); retorna e? x.makeArray (e): this}). filter (function () {var e = this.type; retorna this.name &&! x (this) .is (": disabled") && hn.test (this.nodeName) &&! dn.test (e) && (this.checked | Ct.test (e))}). Map (function (e, t) {var n = x (this) .val (); return null == n? Null: x.isArray (n)? X .map (n, função (e) {retornar {nome: t.name, valor: e.replace (fn, "\ r \ n")}}): {nome: t.name, valor: n.replace ( fn, "\ r \ n")}}). get ()}}), x.param = função (e, n) {var r, i = [], o = função (e, t) {t = x.isFunction (t)? t (): null == t? "": t, i [comprimento] = encodeURIComponent (e) + "=" + encodeURIComponent (t)}; if (n === t && (n = x.ajaxSettings && x.ajaxSettings.traditional), x.isArray (e) || e.jquery &&! x.isPlainObject (e)) x.each (e, function () {o (this.name, this.value)}); else for (r in e) gn (r, e [r], n, o); return i.join ("&"). replace (cn, "+")}; função gn (e, t, n, r) {var i; if (x.isArray (t)) x.each (t, função (t, i) {n || pn.test (e)? r (e , i): gn (e + "[" + ("objeto" == tipo de i? t: "") + "]", i, n, r)}); caso contrário, se (n || "objeto"! = = x.type (t)) r (e, t); caso contrário, para (i in t) gn (e + "[" + i + "]", t [i], n, r)} x.each ("blur foco foco foco foco carga carregamento redimensionar rolagem descarregar clique dblclick mouse com mouse mousemove mouseover mouseout mouseenter mouseleave alterar selecionar enviar tecla pressionada tecla pressionada erro de contexto contextmenu ".split (" "), função (e, t) {x.fn [t] = function (e, n) {return argument.length> 0? this.on (t, null, e, n): this.trigger (t)}}), x.fn.extend ({hover: function (e, t) {return this.mouseenter (e) .mouseleave (t || e)}, bind: function (e, t, n) {retorna this.on (e, null,t, n)}, unbind: function (e, t) {retorna this.off (e, null, t)}, delega: function (e, t, n, r) {retorna this.on (t, e, n, r)}, undelegate: function (e, t, n) {retornar 1 === argumentos.length? this.off (e, "**"): this.off (t, e || "** ", n)}}); var mn, yn, vn = x.now (), bn = / \? /, xn = / #. * $ /, wn = / ([? &]) _ = [^ &] * /, Tn = / ^ (. *?): [\ T] * ([^ \ r \ n] *) \ r? $ / Gm, Cn = / ^ (?: sobre | app | app- armazenamento |. + - extensão | arquivo | res | widget): $ /, Nn = / ^ (?: GET | HEAD) $ /, kn = / ^ \ / \ //, En = / ^ ([\ w. + -] +:) (?: \ / \ / ([^ \ /? #:] *) (? :: (\ d +) |) |) |) /, Sn = x.fn.load, An = {} , jn = {}, Dn = "* /". concat ("*"); tente {yn = o.href} captura (Ln) {yn = a.createElement ("a"), yn.href = "" , yn = yn.href} mn = En.exec (yn.toLowerCase ()) || []; function Hn (e) {return function (t, n) {"string"! = typeof t && (n = t, t = "*"); var r, i = 0, o = t.toLowerCase (). match (T) || []; if (x.isFunction (n)) while (r = o [i ++]) " + "=== r [0]? (r = r.fatia (1) || "*", (e [r] = e [r] || []). unshift (n)) :( e [r] = e [r] || []). push ( n)}} função qn (e, n, r, i) {var o = {}, a = e === jn; função s (l) {var u; retorno o [l] =! 0, x. cada (e [l] || [], função (e, l) {var c = l (n, r, i); retorna "string"! = tipo de c || a || o [c]? a? ! (u = c): t: (n.dataTypes.unshift (c), s (c) ,! 1)}), u} retorna s (n.dataTypes [0]) ||! o ["*" ] && s ("*")} função _n (e, n) {var r, i, o = x.ajaxSettings.flatOptions || {}; para (i em n) n [i]! == t && ((o [i]? e: r || (r = {})) [i] = n [i]); retorna r && x.extend (! 0, e, r), e} x.fn.load = function (e , n, r) {if ("string"! = tipo de e && Sn) retorna Sn.apply (this, argumentos); var i, o, a, s = this, l = e.indexOf (""); return l> = 0 && (i = e.slice (l, e.length), e = e.slice (0, l)), x.isFunção (n)? (R = n, n = t): n && "objeto" = = typeof n && (a = "POST"), s.length> 0 && x.ajax ({url: e, tipo: a,dataType: "html", data: n}). done (função (e) {o = argumentos, s.html (i? x ("<div>")) .append (x.parseHTML (e)). find ( i): e)}). complete (função r && (e, t) {s.each (r, o || [e.responseText, t, e])}), isso}, x.each (["ajaxStart" , "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], função (e, t) {x.fn [t] = função (e) {retorna this.on (t, e) }}), x.extend ({active: 0, lastModified: {}, etag: {}, ajaxSettings: {url: yn, tipo: "GET", isLocal: Cn.test (mn [1]), global: ! 0, processData:! 0, assíncrono:! 0, contentType: "application / x-www-form-urlencoded; charset = UTF-8", aceita: {"*": Dn, texto: "text / plain", html: "text / html", xml: "application / xml, text / xml", json: "application / json, text / javascript"}, conteúdo: {xml: / xml /, html: / html /, json: / json /},responseFields: {xml: "responseXML", texto: "responseText", json: "responseJSON"}, conversores: {"* text": String, "text html":! 0, "text json": x.parseJSON, " texto xml ": x.parseXML}, flatOptions: {url:! 0, contexto:! 0}}, ajaxSetup: function (e, t) {retorna t? _n (_n (e, x.ajaxSettings), t): _n (x.ajaxSettings, e)}, ajaxPrefilter: Hn (An), ajaxTransport: Hn (jn), ajax: function (e, n) {"objeto" == tipo de e && (n = e, e = t), n = n || {}; var r, i, o, a, s, l, u, c, p = x.ajaxSetup ({}, n), f = p. contexto || p, d = p. contexto && (f.nodeType || f.jquery)? x (f): x.event, h = x.Deferido (), g = x.Callbacks ("uma vez memória"), m = p.statusCode || {} , y = {}, v = {}, b = 0, w = "cancelado", C = {readyState: 0, getResponseHeader: função (e) {var t; if (2 === b) {if (! c) {c = {}; while (t = Tn.exec (a)) c [t [1] .toLowerCase ()] = t [2]} t = c [e.toLowerCase ()]} return null = = t? null: t},getAllResponseHeaders: function () {return 2 === b? a: null}, setRequestHeader: function (e, t) {var n = e.toLowerCase (); return b || (e = v [n] = v [ n] || e, y [e] = t), isso}, substituiMimeType: função (e) {retorna b || (p.mimeTipo = e), isso}, statusCode: function (e) {var t; if (e) se (2> b) para (t em e) m [t] = [m [t], e [t]]; caso contrário, C.sempre (e [C.status]); retorne isso}, aborte : função (e) {var t = e || w; retorna u && u.abort (t), k (0, t), isso}}; if (h.promise (C) .complete = g.add, C. success = C.done, C.error = C.fail, p.url = ((e || p.url || yn) + ""). replace (xn, ""). replace (kn, mn [1 ] + "//"), p.type = n.method || n.type || p.method || p.type, p.dataTypes = x.trim (p.dataType || "*"). toLowerCase () .match (T) || [""], null == p.crossDomain && (r = En.exec (p.url.toLowerCase ()), p.crossDomain =! (! r || r [1] === mn [1] && r [2] === mn [2] && (r [3] || ("http:" === r [1]? "80": "443 ")) === (mn [3] || (" http: "=== mn [1]?" 80 ":" 443 "))))), p.data && p.processData &&" string "! = Typeof p.data && (p.data = x.param (p.data, p.tradicional)), qn (An, p, n, C), 2 === b) return C; l = p.global, l && 0 = == x.active ++ && x.event.trigger ("ajaxStart"), p.type = p.type.toUpperCase (), p.hasContent =! Nn.test (p.type), o = p.url, p.hasContent || (p.data && (o = p.url + = (bn.test (o)? "&": "?") + p.data, exclua p.data), p.cache ===! 1 && (p.url = wn.test (o)? O.replace (wn, "$ 1 _ =" + vn ++): o + (bn.test (o)? "&": "?") + "_ =" + vn ++)), p.ifModified && (x.lastModified [o] && C.setRequestHeader ("If-Modified-Since", x.lastModified [o]), x.etag [o] && C.setRequestHeader ("If-None- Correspondência ", x.etag [o])), (p.data && p.hasContent && p.contentType! ==! 1 || n.contentType) && C.setRequestHeader ("Tipo de conteúdo", p.contentType), C.setRequestHeader ("Accept", p.dataTypes [0] && p.accepts [p.dataTypes [0]]? P.accepts [p.dataTypes [0]] + ("*"! == p.dataTypes [0]? "," + Dn + "; q = 0,01": ""): p.accepts ["*"]); para (i em p.headers) C.setRequestHeader (i, p.headers [i]); if (p.beforeSend && (p.beforeSend.call (f, C, p) === ! 1 || 2 === b)) retornou C.abort (); w = "abortar"; para (i em {sucesso: 1, erro: 1, completo: 1}) C [i] (p [i ]); if (u = qn (jn, p, n, C)) {C.readyState = 1, l && d.trigger ("ajaxSend", [C, p]), p.async && p.timeout> 0 && (s = setTimeout (function () {C.abort ("timeout")}, p.timeout)); tente {b = 1, u.send (y, k)} catch (N) {if (! (2> b) ) jogue N; k (-1, N)}} else k (-1, "No Transport"); função k (e, n, r,i) {var c, y, v, w, T, N = n; 2! == b && (b = 2, s && clearTimeout (s), u = t, a = i || "", C.readyState = e > 0? 4: 0, c = e> = 200 && 300> e || 304 === e, r && (w = Mn (p, C, r)), w = Ativado (p, w, C, c), c? (p.ifModified && (T = C.getResponseHeader ("Última modificação")), T&& (x.lastModified [o] = T), T = C.getResponseHeader ("etag"), T&& (x.etag [o ] = T)), 204 === e || "HEAD" === p.type? N = "nocontent": 304 === e? N = "não modificado" :( N = w.state, y = w.data, v = erro, c =! v)) :( v = N, (e ||! N) && (N = "erro", 0> e && (e = 0))), C. status = e, C.statusText = (n || N) + "", c? h.resolveWith (f, [y, N, C]): h.rejectWith (f, [C, N, v]), C.statusCode (m), m = t, l && d.trigger (c? "AjaxSuccess": "ajaxError", [C, p, c? Y: v]), g.fireWith (f, [C, N]) , l && (d.trigger ("ajaxComplete", [C, p]), - x.active || x.event.trigger ("ajaxStop")))} retornar C}, getJSON: function (e, t, n) {retornar x.get (e, t, n, "json")}, getScript: function (e, n) { retornar x.get (e, t, n, "script")}}), x.each (["get", "post"], função (e, n) {x [n] = função (e, r , i, o) {return x.isFunction (r) && (o = o || i, i = r, r = t), x.ajax ({url: e, tipo: n, dataType: o, data: r, sucesso: i})}}); function Mn (e, n, r) {var i, o, a, s, l = e.contents, u = e.dataTypes; while ("*" === u [0]) u.shift (), o === t && (o = e.mimeType || n.getResponseHeader ("Tipo de conteúdo")); if (o) para (s em l) if (l [ s] && l [s] .test (o)) {u.shift (s); break} if (u [0] em r) a = u [0]; caso contrário {para (s em r) {if (! u [0] || e.conversores [s + "" + u [0]]) {a = s; break} i || (i = s)} a = a || i} retornar a? (a! = = u [0] && u.unshift (a), r [a]): t} função Ligada (e, t, n, r) {var i, o, a, s, l, u = {}, c = e.dataTypes.slice (); if (c [1]) para (a em conversores eletrônicos) u [a.toLowerCase ()] = e.conversores [a]; o = c.shift (); while (o) if (e.responseFields [o] && (n [e.responseFields [o]] = t) ,! l && r && e.dataFilter && (t = e.dataFilter (t, e.dataType)), l = o, o = c.shift ()) if ("*" === o) o = l; caso contrário, se ("*"! == l && l! == o) {if (a = u [l + "" + o] || u ["*" + o] ,! a) for (i in u) if (s = i.split ("")), s [1] = == o && (a = u [l + "" + s [0]] || u ["*" + s [0]])) {a ===! 0? a = u [i]: u [i ]! ==! 0 && (o = s [0], c.shift (s [1])); break} if (a! ==! 0) if (a && e ["lança"]) t = a (t ); caso contrário, tente {t = a (t)} catch (p) {return {state: "parsererror", erro: a? p: "Nenhuma conversão de" + l + "para" + o}}} return {state: "sucesso", dados: t}} x.ajaxSetup ({aceita: {script: "texto / javascript, aplicativo / javascript, aplicativo / ecmascript, aplicativo / x-ecmascript"}, conteúdo: {script: / (?:java | ecma) script /}, conversores: {"script de texto": função (e) {retorno x.globalEval (e), e}}}), x.ajaxPrefilter ("script", função (e) {e. cache === t && (e.cache =! 1), e.crossDomain && (e.type = "GET", e.global =! 1)}), x.ajaxTransport ("script", função (e) {if (e.crossDomain) {var n, r = a.head || x ("head") [0] || a.documentElement; return {send: function (t, i) {n = a.createElement ("script "), n.async =! 0, e.scriptCharset && (n.charset = e.scriptCharset), n.src = e.url, n.onload = n.onreadystatechange = function (e, t) {(t || ! n.readyState || / loading | complete / .test (n.readyState)) && (n.onload = n.onreadystatechange = null, n.parentNode && n.parentNode.removeChild (n), n = nulo, t || i (200, "success"))}, r.inserirBefore (n, r.firstChild)}, abortar: function () {n && n.onload (t,! 0)}}}}); var Fn = [], Bn = / (=) \? (? = & | $) | \? \? /; x.ajaxSetup ({jsonp: "retorno de chamada", jsonpCallback: function () {var e = Fn.pop () || x.expando + "_" + vn ++; retorne isso [e] =! 0, e}}), x. ajaxPrefilter ("json jsonp", função (n, r, i) {var o, a, s, l = n.jsonp! ==! 1 && (Bn.test (n.url)? "url": "string" == tipo de n.data &&! (n.contentType || ""). indexOf ("application / x-www-form-urlencoded") && Bn.test (n.data) && "data"); return l || " jsonp "=== n.dataTypes [0]? (o = n.jsonpCallback = x.isFunction (n.jsonpCallback)? n.jsonpCallback (): n.jsonpCallback, l? n [l] = n [l]. substituir (Bn, "$ 1" + o): n.jsonp! ==! 1 && (n.url + = (bn.test (n.url)? "&": "?") + n.jsonp + "=" + o), n.converters ["script json"] = function () {return s || x.error (o + "não foi chamado"), s [0]}, n.dataTypes [0] = "json", a = e [o],e [o] = função () {s = argumentos}, i. sempre (função () {e [o] = a, n [o] && (n.jsonpCallback = r.jsonpCallback, Fn.push (o)) , s && x.isFunção (a) && a (s [0]), s = a = t}), "script"): t}); var Pn, Rn, Wn = 0, $ n = e.ActiveXObject && function () { var e; para (e em Pn) Pn [e] (t,! 0)}; function In () {try {return new e.XMLHttpRequest} catch (t) {}} function zn () {try {return new e.ActiveXObject ("Microsoft.XMLHTTP")} catch (t) {}} x.ajaxSettings.xhr = e.ActiveXObject? function () {return! this.isLocal && In () || zn ()}: In, Rn = x.ajaxSettings.xhr (), x.support.cors = !! Rn && "withCredentials" em Rn, Rn = x.support.ajax = !! Rn, Rn && x.ajaxTransport (function (n) {if (! n.crossDomain || x.support.cors) {var r; return {send: function (i, o) {var a, s, l = n.xhr (); if (n.username? l.open (n.type, n.url, n.async, n.username, n.password): l.open (n.type, n.url, n.async), n.xhrFields) para (s em n.xhrFields) l [s] = n.xhrFields [s]; n.mimeType && l.overrideMimeType && l.overrideMimeType (n.mimeType), n.crossDomain || i ["X-Requested-With"] || (i ["X-Requested-With"] = "XMLHttpRequest"); tente {for (s em i) l.setRequestHeader (s, i [s])} catch (u) {} l.send (n .hasContent && n.data || null), r = function (e, i) {var s, u, c, p; try {if (r && (i || 4 === l.readyState)) if (r = t , a && (l.onreadystatechange = x.noop, $ n && delete Pn [a]), i) 4! == l.readyState && l.abort (); else {p = {}, s = l.status, u = l. getAllResponseHeaders (), "string" == tipo de l.responseText && (p.text = l.responseText); tente {c = l.statusText} catch (f) {c = ""} s ||! n.isLocal || n.crossDomain? 1223 === s && (s = 204): s = p.text? 200: 404}} catch (d) {i || o (-1, d)} p && o (s, c, p, u)}, n.async? 4 === l.readyState? setTimeout (r) :( a = ++ Wn, $ n &&(Pn || (Pn = {}, x (e) .unload ($ n)), Pn [a] = r), l.onreadystatechange = r): r ()}, abort: function () {r && r ( t,! 0)}}}}); var Xn, Un, Vn = / ^ (?: alternar | mostrar | ocultar) $ /, Yn = RegExp ("^ (?: ([+ -]) = |) ("+ w +") ([az%] *) $ "," i "), Jn = / filaHooks $ /, Gn = [nr], Qn = {" * ": [function (e, t) {var n = this.createTween (e, t), r = n.cur (), i = Yn.exec (t), o = i && i [3] || (x.cssNumber [e]? "": "px" ), a = (x.cssNúmero [e] || "px"! == o && + r) && Yn.exec (x.css (n.elem, e)), s = 1, l = 20; if (a && a [3]! == o) {o = o || a [3], i = i || [], a = + r || 1; faça s = s || ".5", a / = s , x.style (n.elem, e, a + o); while (s! == (s = n.cur () / r) && 1! == s && - l)} retornar i && (a = n. start = + a || + r || 0, n.unidade = o, n.end = i [1]? a + (i [1] +1) * i [2]: + i [2]), n }]}; função Kn () {retornar setTimeout (função () {Xn = t}), Xn = x.now ()} função Zn (e, t, n) {var r, i = (Qn [t] || []). concat (Qn ["*"]),o = 0, a = i.length; para (; a> o; o ++) if (r = i [o] .call (n, t, e)) retorna r} função er (e, t, n) { var r, i, o = 0, a = Gn.length, s = x.Deferido (). sempre (função () {excluir l.elem}), l = função () {se (i) retornar! 1; var t = Xn || Kn (), n = Math.max (0, u.startTime + u.duration-t), r = n / u.duração || 0, o = 1-r, a = 0, l = u.tweens.length; para (; l> a; a ++) u.tweens [a] .run (o); return s.notifyWith (e, [u, o, n]), 1> o && l? n : (s.resolveWith (e, [u]) ,! 1)}, u = s.promise ({elem: e, props: x.extend ({}, t), opta: x.extend (! 0, {specialEasing: {}}, n), originalProperties: t, originalOptions: n, startTime: Xn || Kn (), duração: n.duration, tweens: [], createTween: function (t, n) {var r = x.Tween (e, u.opts, t, n, u.opts.specialEasing [t] || u.opts.easing); retorna u.tweens.push (r), r}, stop: function (t) {var n = 0, r = t? u.tweens.length: 0; se (i) retornar isso; para (i =! 0; r> n; n ++) u.tweens [n] .run (1); return t? s.resolveWith (e, [u, t]): s.rejectWith (e, [u, t]), isso}}), c = u.props;for (tr (c, u.opts.specialEasing); a> o; o ++) if (r = Gn [o] .call (u, e, c, u.opts)) retorna r; retorna x.map (c , Zn, u), x.isFunction (u.opts.start) && u.opts.start.call (e, u), x.fx.timer (x.extend (l, {elem: e, anim: u, fila: u.opts.queue})), u.progress (u.opts.progress). concluído (u.opts.done, u.opts.complete) .fail (u.opts.fail) .sempre (u. opts.always)} função tr (e, t) {var n, r, i, o, a; for (n em e) if (r = x.camelCase (n), i = t [r], o = e [n], x.isArray (o) && (i = o [1], o = e [n] = o [0]), n! == r && (e [r] = o, exclua e [n ]), a = x.cssHooks [r], a && "expand" em a) {o = a.expand (o), exclua e [r]; para (n in o) n em e || (e [n ] = o [n], t [n] = i)} else t [r] = i} x.Animação = x.extend (er, {interpolador: função (e, t) {x.isFunção (e)? (t = e, e = ["*"]): e = e.split (""); var n, r = 0, i = comprimento comprimento; para (; i> r; r ++) n = e [ r], Qn [n] = Qn [n] || [], Qn [n] .shift (t)}, pré-filtro: função (e, t) {t? Gn.unshift (e): Gn.push ( e)}});função nr (e, t, n) {var r, i, o, a, s, l, u = isso, c = {}, p = e.style, f = e.nodeType && nn (e), d = x ._data (e, "fxshow"); n.queue || (s = x._queueHooks (e, "fx"), nulo == s.unqueued && (s.unqueued = 0, l = s.empty.fire, s.empty.fire = function () {s.unqueued || l ()}), s.unqueued ++, u.always (function () {u.always (function () {s.unqueued -, x.queue (e, "fx"). length || s.empty.fire ()})})), 1 === e.nodeType && ("altura" em t || "largura" em t) && (n.overflow = [p.overflow, p.overflowX, p.overflowY], "inline" === x.css (e, "display") && "none" === x.css (e, "float") && ( x.support.inlineBlockNeedsLayout && "inline"! == ln (e.nodeName)? p.zoom = 1: p.display = "bloco inline")), n.overflow && (p.overflow = "oculto", x. support.shrinkWrapBlocks || u.always (function () {p.overflow = n.overflow [0], p.overflowX = n.flowflow [1], p.overflowY = n.flowflow [2]})); para (r em t) se (i = t [r], Vn.exec (i )) {if (excluir t [r], o = o || "alternar" === i, i === (f? "ocultar": "mostrar")) continuar; c [r] = d && d [r ] || x.style (e, r)} if (! x.isEmptyObject (c)) {d? "oculto" em d && (f = d.hidden): d = x._dados (e, "fxshow", {}), o && (d.hidden =! f), f? x (e) .show (): u.done (function () {x (e) .hide ()}), u.done (function ( ) {var t; x._removeData (e, "fxshow"); para (t em c) x.style (e, t, c [t])}); para (r em c) a = Zn (f? d [r]: 0, r, u), r em d || (d [r] = a.art, f && (a.end = a.art, a.start = "width" === r || "height" === r? 1: 0))}} função rr (e, t, n, r, i) {retorna novo rr.prototype.init (e, t, n, r, i)} x. Tween = rr, rr.prototype = {construtor: rr, init: função (e, t, n, r, i, o) {this.elem = e, this.prop = n, this.easing = i || " swing ", this.options = t, this.start = this.agora = this.cur (), this.end = r, this.unit = o || (x.cssNumber [n]? "": "px")}, cur: function () {var e = rr.propHooks [this.prop]; return e && e.get? e.get (this): rr.propHooks._default.get (this)}, execute: function (e) {var t, n = rr.propHooks [this.prop] ; return this.pos = t = this.options.duration? x.easing [this.easing] (e, this.options.duration * e, 0,1, this.options.duration): e, this.now = (this.end-this.start) * t + this.start, this.options.step && this.options.step.call (this.elem, this.now, this), n && n.set? n.set (this): rr.propHooks._default.set (this), this}}, rr.prototype.init.prototype = rr.prototype, rr.propHooks = {_ padrão: {get: function (e) {var t; return null == e .elem [e.prop] || e.elem.style && null! = e.elem.style [e.prop]? (t = x.css (e.elem, e.prop, ""), t && "auto" ! == t? t: 0): e.elem [e.prop]}, defina: função (e) {x.fx.step [e.prop]? x.fx.step [e.prop] (e): e.elem.style && (null! = e.elem.style [x.cssProps [e.prop]] || x.cssHooks [e.prop])? x.style (e.elem, e.prop, e.now + e.unit): e.elem [e.prop] = e.now}}}, rr.propHooks.scrollTop = rr.propHooks.scrollLeft = {set: function (e) {e .elem.nodeType && e.elem.parentNode && (e.elem [e.prop] = e.now)}}, x.each (["alternar", "mostrar", "ocultar"], função (e, t) { var n = x.fn [t]; x.fn [t] = função (e, r, i) {return null == e || "boolean" == tipo de e? n.apply (isto, argumentos): this.animate (ir (t,! 0), e, r, i)}}), x.fn.extend ({fadeTo: function (e, t, n, r) {retorna this.filter (nn). css ("opacidade", 0). show (). end (). animar ({opacidade: t}, e, n, r)}, animar: função (e, t, n, r) {vari = x .isEmptyObject (e), o = x.speed (t, n, r), a = function () {var t = er (this, x.extend ({}, e), o); (i || x ._data (this, "finish")) && t.stop (! 0)}; return a.finish = a, i || o.queue ===! 1? this.each (a):this.queue (o.queue, a)}, stop: function (e, n, r) {vari = function (e) {var t = e.stop; delete e.stop, t (r)}; return "string"! = tipo de e && (r = n, n = e, e = t), n && e! ==! 1 && this.queue (e || "fx", []), this.each (function () {var t =! 0, n = nulo! = e && e + "queueHooks", o = x.timers, a = x._data (isto); se (n) a [n] && a [n] .stop &&i (a [n]) ; else for (n em a) a [n] && a [n] .stop && Jn.test (n) &&i (a [n]); for (n = o.length; n -;) o [n] .elem ! == this || null! = e && o [n]. fila! == e || (o [n] .anim.stop (r), t =! 1, o.splice (n, 1)); ( t ||! r) && x.dequeue (this, e)})}, finish: function (e) {return e! ==! 1 && (e = e || "fx"), this.each (function () {var t, n = x._dados (este), r = n [e + "fila"], i = n [e + "filaHooks"], o = x.timers, a = r? r.length: 0; (n.finish =! 0, x.queue (this, e, []), i && i.stop && i.stop.call (this,! 0), t = o.comprimento; t -;) o [t] .elem === isso && o [t] .queue === e && (o [t] .anim.stop (! 0), o.splice (t, 1)); for (t = 0; a> t; t ++) r [t] && r [t] .finish && r [t] .finish.call (this); delete n.finish})}}); function ir (e, t) {var n, r = {height: e}, i = 0; para (t = t? 1: 0; 4> i; i + = 2-t) n = Zt [i], r ["margem" + n ] = r ["preenchimento" + n] = e; retorna t && (r.opacidade = largura.r = e), r} x.each ({slideDown: ir ("show"), slideUp: ir ("hide") ), slideToggle: ir ("alternar"), fadeIn: {opacidade: "show"}, fadeOut: {opacidade: "ocultar"}, fadeToggle: {opacidade: "alternar"}}, função (e, t) {x .fn [e] = função (e, n, r) {retorna this.animate (t, e, n, r)}}), x.speed = função (e, t, n) {var r = e && " objeto "== tipo de e? x.extend ({}, e): {completo: n ||! n && t || x.isFunção (e) && e, duração: e, flexibilização: n && t || t &&! x.isFunction ( t) && t};retornar r.duração = x.fx.off? 0: "número" == tipo de r.duração? r.duração: r.duração em x.fx.speeds? x.fx.speeds [r.duration]: x. fx.speeds._default, (null == r.queue || r.queue ===! 0) && (r.queue = "fx"), r.old = r.complete, r.complete = function () {x.isFunction (r.old) && r.old.call (this), r.queue && x.dequeue (this, r.queue)}, r}, x.easing = {linear: function (e) {return e} , swing: function (e) {return.5-Math.cos (e * Math.PI) / 2}}, x.timers = [], x.fx = rr.prototype.init, x.fx.tick = function () {var e, n = x.timers, r = 0; for (Xn = x.now (); n.length> r; r ++) e = n [r], e () || n [r ]! == e || n.splice (r -, 1); n.length || x.fx.stop (), Xn = t}, x.fx.timer = função (e) {e () && x.timers.push (e) && x.fx.start ()}, x.fx.interval = 13, x.fx.start = function () {Un || (Un = setInterval (x.fx.tick, x .fx.interval))}, x.fx.stop = function () {clearInterval (Un), Un = null}, x.fx.speeds = {slow: 600, fast: 200, _default:400}, x.fx.step = {}, x.expr && x.expr.filters && (x.expr.filters.animated = função (e) {return x.grep (x.timers, função (t) {return e = == t.elem}). length}), x.fn.offset = function (e) {if (argument.length) retorna e === t? this: this.each (function (t) {x.offset .setOffset (this, e, t)}); var n, r, o = {top: 0, esquerda: 0}, a = this [0], s = a && a.ownerDocument; if (s) return n = s .documentElement, x.contains (n, a)? (tipo de a.getBoundingClientRect! == i && (o = a.getBoundingClientRect ()), r = ou (s), {top: o.top + (r.pageYOffset || n.scrollTop) - (n.clientTop || 0), esquerda: o.left + (r.pageXOffset || n.scrollLeft) - (n.clientLeft || 0)}): o}, x.offset = {setOffset : função (e, t, n) {var r = x.css (e, "posição"); "estática" === r && (e.style.position = "relativa"); var i = x (e) , o = i.offset (), a = x.css (e, "superior"), s = x.css (e, "esquerda"), l = ("absoluto" === r || "fixo"=== r) && x.inArray ("auto", [a, s])> - 1, u = {}, c = {}, p, f; l? (c = posição i (), p = c.top, f = c.left) :( p = parseFloat (a) || 0, f = parseFloat (s) || 0), x.isFunção (t) && (t = t.call (e, n , o)), null! = t.top && (u.top = t.top-o.top + p), null! = t.left && (u.left = t.left-o.left + f) ", usando "em t? t.using.call (e, u): i.css (u)}}, x.fn.extend ({position: function () {if (this [0]) {var e, t , n = {top: 0, esquerda: 0}, r = this [0]; return "fixed" === x.css (r, "position")? t = r.getBoundingClientRect () :( e = this .offsetParent (), t = this.offset (), x.nodeName (e [0], "html") || (n = e.offset ()), n.top + = x.css (e [0] , "borderTopWidth",! 0), n.left + = x.css (e [0], "borderLeftWidth",! 0)), {top: t.top-n.top-x.css (r, "marginTop ",! 0), à esquerda: t.left-n.left-x.css (r," marginLeft ",! 0)}}}, offsetParent: function () {retorna this.map (function () {var e = isso.offsetParent || s; while (e &&! x.nodeName (e, "html") && "static" === x.css (e, "position")) e = e.offsetParent; return e || s}) }}), x.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, função (e, n) {var r = / Y / .test (n); x.fn [e] = function ( i) {return x.access (esta função (e, i, o) {var a = ou (e); return o === t? a? n em a? a [n]: a.document.documentElement [i]: e [i] :( a? a.scrollTo (r? x (a) .scrollLeft (): o, r? o: x (a) .scrollTop ()): e [i] = o, t)}, e, i, argument.length, null)}}); function or (e) {return x.isWindow (e)? e: 9 === e.nodeType? e.defaultView || e.parentWindow :! 1} x.each ({Height: "height", Width: "width"}, função (e, n) {x.each ({padding: "inner" + e, conteúdo: n, "": " externo "+ e}, função (r, i) {x.fn [i] = função (i, o) {var a = argumentos.length && (r ||" booleano "! = tipo de i), s = r | | (i ===! 0 || o ===!0? "Margin": "border"); return x.access (esta função (n, r, i) {var o; return x.isWindow (n)? N.document.documentElement ["client" + e] : 9 === n.nodeType? (O = n.documentElement, Math.max (n.body ["rolagem" + e], o ["rolagem" + e], n.body ["deslocamento" + e]] , o ["deslocamento" + e], o ["cliente" + e])): i === t? x.css (n, r, s): x.style (n, r, i, s) }, n, a? i: t, a, null)}})}), x.fn.size = function () {retorna this.length}, x.fn.andSelf = x.fn.addBack, "objeto "== typeof module && module &&" object "== typeof module.exports? module.exports = x: (e.jQuery = e. $ = x," function "== typeof define && define.amd && define (" jquery ", [], function () {return x}))}) (janela);cliente "+ e]: 9 === n.nodeType? (o = n.documentElement, Math.max (n.body [" scroll "+ e], o [" scroll "+ e], n.body [" deslocamento "+ e], o [" deslocamento "+ e], o [" cliente "+ e])): i === t? x.css (n, r, s): x.style (n, r , i, s)}, n, a? i: t, a, null)}})}), x.fn.size = function () {retorna this.length}, x.fn.andSelf = x.fn .addBack, "objeto" == tipo de módulo && módulo && "objeto" = = tipo de módulo.exportação? módulo.exportação = x: (e.jQuery = e. $ = x, "função" == tipo de definição && define.amd && define ("jquery" , [], function () {return x}))}) (janela);cliente "+ e]: 9 === n.nodeType? (o = n.documentElement, Math.max (n.body [" scroll "+ e], o [" scroll "+ e], n.body [" deslocamento "+ e], o [" deslocamento "+ e], o [" cliente "+ e])): i === t? x.css (n, r, s): x.style (n, r , i, s)}, n, a? i: t, a, null)}})}), x.fn.size = function () {retorna this.length}, x.fn.andSelf = x.fn .addBack, "objeto" == tipo de módulo && módulo && "objeto" = = tipo de módulo.exportação? módulo.exportação = x: (e.jQuery = e. $ = x, "função" == tipo de definição && define.amd && define ("jquery" , [], function () {return x}))}) (janela);length}, x.fn.andSelf = x.fn.addBack, "objeto" == tipo de módulo && module && "objeto" = tipo de módulo.exportações? module.exports = x: (e.jQuery = e. $ = x, " função "== tipo de definir && define.amd && define (" jquery ", [], função () {return x}))}) (window);length}, x.fn.andSelf = x.fn.addBack, "objeto" == tipo de módulo && module && "objeto" = tipo de módulo.exportações? module.exports = x: (e.jQuery = e. $ = x, " função "== tipo de definir && define.amd && define (" jquery ", [], função () {return x}))}) (window);